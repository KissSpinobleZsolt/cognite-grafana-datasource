{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"lodash\"","webpack:///./types.ts","webpack:///./utils.ts","webpack:///./parser/events-assets/index.ts","webpack:///./constants.ts","webpack:///../node_modules/deepdash/getFilterDeep.js","webpack:///../node_modules/deepdash/getPathToString.js","webpack:///../node_modules/deepdash/getEachDeep.js","webpack:///./datasource.ts","webpack:///../node_modules/ms/index.js","webpack:///./parser/types.ts","webpack:///../node_modules/nearley/lib/nearley.js","webpack:///./parser/ts/index.ts","webpack:///./cdfDatasource.ts","webpack:///./module.ts","webpack:///../node_modules/query-string/index.js","webpack:///../node_modules/strict-uri-encode/index.js","webpack:///../node_modules/decode-uri-component/index.js","webpack:///../node_modules/split-on-first/index.js","webpack:///../node_modules/deepdash/private/getIterate.js","webpack:///../node_modules/deepdash/private/getHasChildren.js","webpack:///../node_modules/deepdash/getCondenseDeep.js","webpack:///../node_modules/deepdash/getCondense.js","webpack:///../node_modules/deepdash/getExists.js","webpack:///../node_modules/deepdash/getObtain.js","webpack:///../node_modules/deepdash/getPaths.js","webpack:///../node_modules/deepdash/getOmitDeep.js","webpack:///../node_modules/deepdash/getPathMatches.js","webpack:///./parser/events-assets/grammar.ts","webpack:///./parser/ts/grammar.ts","webpack:///./connector.ts","webpack:///./query_ctrl.ts","webpack:///external \"app/plugins/sdk\"","webpack:///./css/query_editor.css?f712","webpack:///./css/query_editor.css","webpack:///../node_modules/css-loader/dist/runtime/api.js","webpack:///../node_modules/style-loader/lib/addStyles.js","webpack:///../node_modules/style-loader/lib/urls.js","webpack:///./config_ctrl.ts","webpack:///./annotation_ctrl.ts","webpack:///./variable_query_ctrl.tsx"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_EXTERNAL_MODULE__0__","maybeError","undefined","error","eventFactory","Tab","ParseType","HttpMethod","obj","stringify","omitBy","isNil","milliseconds","lowerBound","Math","max","options","target","dashboardId","panelId","refId","applyFilters","objs","filters","length","filter","every","checkFilter","path","valueToFilter","regex","RegExp","FilterType","RegexEquals","test","RegexNotEquals","NotEquals","compiledGrammar","Grammar","fromCompiled","filterDeep","paths","omitDeep","parseWith","parser","query","result","trimmedQuery","trim","feed","finish","e","message","formatErrorMessage","Error","offset","parseQuery","Parser","title","pointer","Number","isInteger","Array","join","formatQueryParse","type","extractedFilters","objValue","objKey","isUndefined","filtered","reduce","acc","emptyFilters","pathFormat","map","currentPath","parentPath","slice","push","extractedParams","reg","params","parse","DATAPOINTS_LIMIT_WARNING","TIMESERIES_LIMIT_WARNING","failedResponseEvent","datapointsWarningEvent","CacheTime","TimeseriesList","TimeseriesByIds","Default","getPathToString","getEachDeep","getCondenseDeep","getExists","getObtain","_","eachDeep","pathToString","obtain","condenseDeep","exists","predicate","iteratee","cloneDeep","leafsOnly","leavesOnly","onTrue","onFalse","onUndefined","childrenPath","skipChildren","rootReply","eachDeepOptions","merge","checkCircular","keepCircular","condense","keepIfEmpty","includeRoot","callbackAfterIterate","res","isArray","isObject","replies","foundCircular","parent","context","curPath","afterIterate","isCircular","unset","circularParent","reply","isLeaf","clone","empty","set","isPlainObject","eachRight","parents","each","cv","has","replaceCircularBy","rxArrIndex","rxVarName","isString","accumulator","toString","replace","notChainable","getIterate","iterate","callback","identity","rootIsChildren","toPath","Asset","Custom","Timeseries","POST","templateSrv","this","instanceSettings","warning","data","label","tab","id","range","time","ceil","QueryParserTypes","lexer","column","state","err","lines","table","lockIndices","hasAggregates","route","args","wrap","separateWith","customRes","custom","expression","idEither","serie","isAggregated","filterIsString","aggregateProp","metadata","timestamp","items","string","cacheTime","queryWithoutId","request","chunkSize","chunk","fullLimit","method","requestId","getOptions","CogniteQueryCtrl","item","styleTarget","insertBefore","style","URL","newObj","childNodes","CogniteConfigCtrl","CogniteAnnotationsQueryCtrl","defaults"],"mappings":"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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import {\n  DataQueryOptions,\n  DataQuery,\n  TimeSeries,\n  TimeRange as GrafanaTimeRange,\n  DataSourceSettings,\n} from '@grafana/ui';\n\nexport function isError(maybeError: DataQueryError | any): maybeError is DataQueryError {\n  return (<DataQueryError>maybeError).error !== undefined;\n}\n\n/**\n * Comes from grafana, could be imported in future releases hopefully\n * @param name – event name\n */\nexport const eventFactory = <T = undefined>(name: string): AppEvent<T> => {\n  return { name };\n};\n\nexport type QueryResponse = DataResponse<TimeSeries[]>;\n\nexport interface MetricDescription {\n  readonly text: string;\n  readonly value: number | string;\n}\n\nexport type MetricFindQueryResponse = MetricDescription[];\n\nexport enum Tab {\n  Timeseries = 'Timeseries',\n  Asset = 'Asset',\n  Custom = 'Custom',\n}\n\nexport enum ParseType {\n  Timeseries = 'Timeseries',\n  Asset = 'Asset',\n  Event = 'Event',\n}\n\nexport interface TimeSeriesResponseItem {\n  id: number;\n  externalId?: string;\n  name?: string;\n  isString?: boolean;\n  metadata?: object;\n  unit?: string;\n  assetId?: string;\n  isStep: boolean;\n  description?: string;\n  source?: string;\n  sourceId?: string;\n  createdTime: number;\n  lastUpdatedTime: number;\n  selected: boolean;\n}\n\nexport type TimeSeriesResponse = Items<TimeSeriesResponseItem>;\n\nexport interface AssetQuery {\n  target: string;\n  includeSubtrees: boolean;\n  old?: AssetQuery;\n  timeseries?: TimeSeriesResponseItem[];\n  func?: string;\n  templatedTarget?: string;\n}\n\nexport interface InputQueryTarget extends DataQuery {\n  target: number | '';\n  aggregation: string;\n  granularity: string;\n  error: string;\n  label: string;\n  tab: Tab;\n  assetQuery: AssetQuery;\n  expr: string;\n  warning: string;\n}\n\nexport interface QueryTarget extends InputQueryTarget {\n  target: number;\n}\n\nexport type QueryFormat = 'json';\n\nexport type QueryOptions = DataQueryOptions<InputQueryTarget>;\n\nexport type Tuple<T> = [T, T];\n\nexport interface Range<T> {\n  min?: T;\n  max?: T;\n}\n\n/**\n * Comes from grafana, could be imported in future releases hopefully\n */\nexport interface AppEvent<T> {\n  readonly name: string;\n  payload?: T;\n}\n\nexport enum HttpMethod {\n  POST = 'POST',\n  GET = 'GET',\n  PATCH = 'PATCH',\n  DELETE = 'DELETE',\n}\n\nexport interface DataSourceRequestOptions {\n  url: string;\n  method: HttpMethod;\n  retry?: number;\n  requestId?: string;\n  headers?: { [s: string]: string };\n  silent?: boolean;\n  data?: object;\n}\n\nexport interface Timestamp {\n  timestamp: number;\n}\n\nexport type MetaResponses = Responses<ResponseMetadata, DataQueryRequestResponse>;\n\nexport type SuccessResponse<Metadata, Response> = { metadata: Metadata; result: Response };\nexport type FailResponse<Metadata> = { metadata: Metadata; error: any };\nexport type Responses<Metadata, Response> = {\n  failed: FailResponse<Metadata>[];\n  succeded: SuccessResponse<Metadata, Response>[];\n};\n\nexport interface TimeSeriesDatapoint extends Timestamp {\n  value: string;\n}\n\nexport interface TimeSeriesAggregateDatapoint extends Timestamp {\n  average?: number;\n  max?: number;\n  min?: number;\n  count?: number;\n  sum?: number;\n  interpolation?: number;\n  stepInterpolation?: number;\n  continuousVariance?: number;\n  discreteVariance?: number;\n  totalVariation?: number;\n}\n\nexport interface Datapoint {\n  id: number;\n  externalId?: string;\n  isStep: boolean;\n  isString: boolean;\n  unit?: string;\n  datapoints: TimeSeriesDatapoint[] | TimeSeriesAggregateDatapoint[];\n}\n\nexport type Datapoints = Items<Datapoint>;\n\nexport interface DataQueryRequestResponse extends DataResponse<Datapoints> {\n  config: {\n    data: {\n      aggregates: string;\n      limit: number;\n    };\n  };\n}\n\nexport interface RequestParams<DataType = any> {\n  path: string;\n  data: DataType;\n  method: HttpMethod;\n  params?: { [s: string]: any };\n  requestId?: string;\n  cacheTime?: string;\n}\n\nexport type DataQueryError = {\n  error: {\n    cancelled?: boolean;\n    data: {\n      error?: {\n        message: string;\n        notFound?: string[];\n      };\n    };\n    status: number;\n  };\n};\n\nexport type QueriesData = {\n  items: DataQueryRequestItem[];\n  target: QueryTarget;\n}[];\n\nexport type ResponseMetadata = { labels: string[]; target: QueryTarget };\n\nexport interface DataQueryAlias {\n  alias: string;\n  id: number;\n  aggregate?: string;\n  granularity?: string;\n}\n\nexport type IdEither =\n  | {\n      id: number;\n    }\n  | {\n      externalId: string;\n    };\n\nexport type DataQueryRequestItem = {\n  expression?: string;\n  start?: string | number;\n  end?: string | number;\n  limit?: number;\n  granularity?: string;\n  aggregates?: string[];\n  id?: number;\n};\n\nexport type Aggregates = Pick<DataQueryRequest, 'aggregates'>;\nexport type Granularity = Pick<DataQueryRequest, 'granularity'>;\n\nexport interface DataQueryRequest {\n  items: DataQueryRequestItem[];\n  start?: string | number;\n  end?: string | number;\n  limit?: number;\n  aggregates?: string[];\n  granularity?: string;\n}\n\nexport interface Annotation {\n  datasource: string;\n  enable: boolean;\n  hide: boolean;\n  iconColor: string;\n  limit: number;\n  name: string;\n  query: string;\n  filter: string;\n  error: string;\n  type: string;\n  tags: string[];\n}\n\nexport interface AnnotationQueryOptions {\n  range: GrafanaTimeRange;\n  rangeRaw: GrafanaTimeRange;\n  annotation: Annotation;\n  dashboard: number;\n}\n\nexport interface AnnotationResponse {\n  annotation: Annotation;\n  title: string;\n  time: number;\n  timeEnd?: number;\n  text: string;\n  tags?: string[];\n  isRegion?: boolean;\n}\n\nexport interface AnnotationSearchQuery {\n  description: string;\n  type: string;\n  subtype: string;\n  minStartTime: number;\n  maxStartTime: number;\n  minEndTime: number;\n  maxEndTime: number;\n  minCreatedTime: number;\n  maxCreatedTime: number;\n  minLastUpdatedTime: number;\n  maxLastUpdatedTime: number;\n  // format is {\"k1\": \"v1\", \"k2\": \"v2\"}\n  metadata: string;\n  assetIds: number[];\n  assetSubtrees: number[];\n  sort: 'startTime' | 'endTime' | 'createdTime' | 'lastUpdatedTime';\n  dir: 'asc' | 'desc';\n  limit: number;\n  offset: 0;\n}\n\nexport interface Event {\n  id: number;\n  startTime: number;\n  endTime: number;\n  description: string;\n  type: string;\n  subtype: string;\n  assetIds: number[];\n  source: string;\n  sourceId: string;\n}\n\nexport type Events = Items<Event>;\n\nexport type DataEvents = DataResponse<Events>;\n\nexport type AnnotationQueryRequestResponse = DataResponse<DataEvents>;\n\nexport interface DataResponse<T> {\n  data: T;\n}\n\nexport type Items<T = object> = {\n  items: T[];\n};\n\nexport type CursorResponse<T> = DataResponse<Items<T> & { nextCursor?: string }>;\n\nexport type Response<T = object> = DataResponse<{\n  items: T[];\n}>;\n\nexport type TimeseriesFilterQuery = {\n  filter?: {\n    description?: string;\n    assetSubtreeIds?: IdEither[];\n    assetIds?: string[];\n    [s: string]: any; // so we auto-support next features\n  };\n  cursor?: string;\n} & Limit;\n\nexport type Limit = {\n  limit?: number;\n};\n\nexport interface Cursor {\n  cursor?: string;\n}\n\nexport interface VariableQueryData {\n  query: string;\n  error?: string;\n}\n\nexport interface VariableQueryProps {\n  query: string;\n  onChange: (query: VariableQueryData, description: string) => void;\n  datasource: any;\n  templateSrv: any;\n}\n\nexport interface CogniteDataSourceSettings extends DataSourceSettings {\n  jsonData: {\n    authType: string;\n    defaultRegion: string;\n    cogniteProject: string;\n  };\n}\n\nexport interface Metadata {\n  [name: string]: string;\n}\n\nexport type TimeRange = Range<number>;\nexport type CogniteInternalId = number;\nexport type CogniteExternallId = string;\n\nexport interface FilterRequestParams {\n  metadata?: Metadata;\n  assetSubtreeIds?: IdEither[];\n  createdTime?: TimeRange;\n  lastUpdatedTime?: TimeRange;\n  externalIdPrefix?: string;\n}\n\nexport interface AssetsFilterRequestParams extends FilterRequestParams {\n  name?: string;\n  parentIds?: CogniteInternalId[];\n  parentExternalIds?: CogniteExternallId[];\n  rootIds?: IdEither[];\n  source?: string;\n  root?: boolean;\n}\n\nexport interface TimeseriesFilterRequestParams extends FilterRequestParams {\n  name?: string;\n  unit?: string;\n  isString?: boolean;\n  isStep?: boolean;\n  assetIds?: CogniteInternalId[];\n  assetExternalIds?: CogniteExternallId[];\n  rootAssetIds?: IdEither[];\n}\n\nexport interface EventsFilterRequestParams extends FilterRequestParams {\n  startTime?: TimeRange;\n  endTime?: TimeRange;\n  assetIds?: CogniteInternalId[];\n  assetExternalIds?: CogniteExternallId[];\n  rootAssetIds?: IdEither[];\n  source?: string;\n  type?: string;\n  subtype?: string;\n}\n\nexport interface FilterRequest<Filter> extends Limit, Cursor {\n  filter: Filter;\n}\n\nexport interface QueryRequestError {\n  refId: string;\n  error: string;\n}\n\nexport interface QueryDatapointsWarning {\n  refId: string;\n  warning: string;\n}\n","import { isNil, omitBy, get } from 'lodash';\nimport { QueryOptions, QueryTarget } from './types';\nimport { stringify } from 'query-string';\nimport ms from 'ms';\nimport { FilterType, ParsedFilter } from './parser/types';\n\nexport function getQueryString(obj: any) {\n  return stringify(omitBy(obj, isNil));\n}\n\nexport function toGranularityWithLowerBound(milliseconds: number, lowerBound = 1000): string {\n  return ms(Math.max(milliseconds, lowerBound));\n}\n\n// used for generating the options.requestId\nexport function getRequestId(options: QueryOptions, target: QueryTarget) {\n  return `${options.dashboardId}_${options.panelId}_${target.refId}`;\n}\n\nexport const applyFilters = <T>(objs: T[], filters: ParsedFilter[]): T[] => {\n  if (!filters.length) {\n    return objs;\n  }\n\n  return objs.filter(obj => filters.every(filter => checkFilter(obj, filter)));\n};\n\nexport const checkFilter = <T>(obj: T, { path, filter, value }: ParsedFilter): boolean => {\n  const valueToFilter = get(obj, path, null);\n  const regex = new RegExp(`^${value}$`);\n\n  switch (filter) {\n    case FilterType.RegexEquals:\n      return regex.test(valueToFilter);\n    case FilterType.RegexNotEquals:\n      return !regex.test(valueToFilter);\n    case FilterType.NotEquals:\n      return value !== valueToFilter;\n  }\n};\n","import _, { get, isUndefined } from 'lodash';\nimport getFilterDeep from 'deepdash/getFilterDeep';\nimport getPaths from 'deepdash/getPaths';\nimport getOmitDeep from 'deepdash/getOmitDeep';\nimport { Parser, Grammar } from 'nearley';\nimport grammar from './grammar';\nimport { ParserResponse, QueryParserResponse } from '../types';\n\nconst compiledGrammar = Grammar.fromCompiled(grammar);\nconst filterDeep = getFilterDeep(_);\nconst paths = getPaths(_);\nconst omitDeep = getOmitDeep(_);\n\nconst parseWith = (parser: Parser, query: string) => {\n  const trimmedQuery = query.trim();\n  let result;\n\n  try {\n    parser.feed(trimmedQuery);\n\n    [result] = parser.finish();\n  } catch (e) {\n    const message = formatErrorMessage(e, trimmedQuery);\n\n    throw new Error(message);\n  }\n\n  if (!result) {\n    const message = formatErrorMessage(\n      { offset: trimmedQuery.length },\n      trimmedQuery,\n      'Parser: Unexpected end of input'\n    );\n\n    throw new Error(message);\n  }\n\n  return result;\n};\n\nconst parseQuery = (query: string): QueryParserResponse => {\n  return parseWith(new Parser(compiledGrammar), query);\n};\n\nconst formatErrorMessage = ({ offset }, query, title = 'Parser: Syntax error'): string => {\n  const pointer = Number.isInteger(offset) ? offset + 1 : query.length;\n  const message = `${query}\\n${Array(pointer).join(' ')}^`;\n\n  return `${title}:\\n${message}`;\n};\n\nconst formatQueryParse = ({ type, query }: QueryParserResponse): ParserResponse => {\n  const extractedFilters = filterDeep(\n    query,\n    (objValue, objKey, { value, filter }) => !isUndefined(value) && filter\n  );\n  const filtered = extractedFilters\n    ? extractedFilters.reduce((acc, c) => ({ ...acc, ...c }), {})\n    : {};\n\n  const emptyFilters = omitDeep(filtered, ['filter', 'value', 'key']);\n  const filters = paths(emptyFilters, { pathFormat: 'array' }).map(path => {\n    const currentPath = path.join('.');\n    const parentPath = path.slice(0, -1);\n    const { filter, key, value } = get(filtered, currentPath);\n\n    parentPath.push(key);\n\n    return { filter, value, path: parentPath.join('.') };\n  });\n\n  const extractedParams = filterDeep(\n    query,\n    (reg, key, { value, filter }) => !(!isUndefined(value) && filter)\n  );\n  const params = extractedParams ? extractedParams.reduce((acc, c) => ({ ...acc, ...c }), {}) : {};\n\n  return { type, params, filters };\n};\n\nconst parse = (query: string): ParserResponse => {\n  const result = parseQuery(query);\n\n  return formatQueryParse(result);\n};\n\nexport { parse, formatQueryParse, parseQuery, parseWith };\n","import { eventFactory, QueryDatapointsWarning, QueryRequestError } from './types';\n\nexport const DATAPOINTS_LIMIT_WARNING =\n  'Datapoints limit was reached, so not all datapoints may be shown. Try increasing the granularity, or choose a smaller time range.';\nexport const TIMESERIES_LIMIT_WARNING =\n  \"Only showing first 100 timeseries. To get better results, either change the selected asset or use 'Custom Query'.\";\n\nexport const failedResponseEvent = eventFactory<QueryRequestError>('failed-request');\nexport const datapointsWarningEvent = eventFactory<QueryDatapointsWarning>('datapoints-warning');\n\nexport const CacheTime = {\n  TimeseriesList: '61s',\n  TimeseriesByIds: '61m',\n  Default: '11s',\n};\n","'use strict';\n\nvar getPathToString = require('./getPathToString.js');\nvar getEachDeep = require('./getEachDeep.js');\nvar getCondenseDeep = require('./getCondenseDeep.js');\nvar getExists = require('./getExists.js');\nvar getObtain = require('./getObtain.js');\n\nfunction getFilterDeep(_) {\n  // console.log('getFilterDeep:', _);\n  var eachDeep = getEachDeep(_);\n  var pathToString = getPathToString(_);\n  var obtain = getObtain(_);\n  var condenseDeep = getCondenseDeep(_);\n  var exists = getExists(_);\n\n  function filterDeep(obj, predicate, options) {\n    predicate = _.iteratee(predicate);\n    if (!options) {\n      options = {};\n    } else {\n      options = _.cloneDeep(options);\n      if (options.leafsOnly !== undefined) {\n        options.leavesOnly = options.leafsOnly;\n      }\n    }\n    if (!options.onTrue) {\n      options.onTrue = {};\n    }\n    if (!options.onFalse) {\n      options.onFalse = {};\n    }\n    if (!options.onUndefined) {\n      options.onUndefined = {};\n    }\n    if (options.childrenPath !== undefined) {\n      if (options.onTrue.skipChildren === undefined) {\n        options.onTrue.skipChildren = false;\n      }\n      if (options.onUndefined.skipChildren === undefined) {\n        options.onUndefined.skipChildren = false;\n      }\n      if (options.onFalse.skipChildren === undefined) {\n        options.onFalse.skipChildren = false;\n      }\n\n      if (options.onTrue.cloneDeep === undefined) {\n        options.onTrue.cloneDeep = true;\n      }\n      if (options.onUndefined.cloneDeep === undefined) {\n        options.onUndefined.cloneDeep = true;\n      }\n      if (options.onFalse.cloneDeep === undefined) {\n        options.onFalse.cloneDeep = true;\n      }\n    }\n    options = _.merge(\n      {\n        checkCircular: false,\n        keepCircular: true,\n        //replaceCircularBy: <by>,\n        leavesOnly: options.childrenPath === undefined,\n        condense: true,\n        cloneDeep: _.cloneDeep,\n        pathFormat: 'string',\n        onTrue: { skipChildren: true, cloneDeep: true, keepIfEmpty: true },\n        onUndefined: {\n          skipChildren: false,\n          cloneDeep: false,\n          keepIfEmpty: false,\n        },\n        onFalse: {\n          skipChildren: true,\n          cloneDeep: false,\n          keepIfEmpty: false,\n        },\n      },\n      options\n    );\n\n    var eachDeepOptions = {\n      pathFormat: options.pathFormat,\n      checkCircular: options.checkCircular,\n      childrenPath: options.childrenPath,\n      includeRoot: options.includeRoot,\n      callbackAfterIterate: true,\n      leavesOnly: false,\n    };\n\n    var res = _.isArray(obj) ? [] : _.isObject(obj) ? {} : null;\n    var replies = {};\n    var rootReply;\n    var foundCircular = [];\n    // console.log('filterDeep → eachDeep', eachDeepOptions);\n    eachDeep(\n      obj,\n      function(value, key, parent, context) {\n        delete context['break'];\n        var curPath = pathToString(context.path);\n        if (!context.afterIterate) {\n          if (!context.isCircular) {\n            // console.log(context.path, { leaf: context.isLeaf });\n            var reply =\n              !options.leavesOnly || context.isLeaf\n                ? predicate(value, key, parent, context)\n                : undefined;\n\n            if (!_.isObject(reply)) {\n              if (reply === undefined) {\n                reply = _.clone(options.onUndefined);\n              } else if (reply) {\n                reply = _.clone(options.onTrue);\n              } else {\n                reply = _.clone(options.onFalse);\n              }\n            }\n            if (reply.empty === undefined) {\n              reply.empty = true;\n            }\n            // console.log(context.path + '?', reply);\n            if (curPath !== undefined) {\n              replies[curPath] = reply;\n\n              // _.eachRight(context.parents, function(parent) {\n              //   var p = pathToString(parent.path);\n              //   if (p !== undefined && !replies[p]) {\n              //     replies[p] = _.clone(options.onUndefined);\n              //     replies[p].empty = reply.empty;\n              //   } else {\n              //     return false;\n              //   }\n              // });\n\n              if (!rootReply) {\n                rootReply = {\n                  skipChildren: false,\n                  cloneDeep: false,\n                  keepIfEmpty: false,\n                  empty: reply.empty,\n                };\n              }\n            } else {\n              rootReply = reply;\n              // console.log('root reply', reply);\n            }\n            // console.log('→', replies);\n            if (reply.keepIfEmpty || !reply.skipChildren) {\n              if (options.cloneDeep && reply.cloneDeep) {\n                if (context.path !== undefined) {\n                  _.set(res, context.path, options.cloneDeep(value));\n                } else {\n                  res = options.cloneDeep(value);\n                }\n              } else {\n                if (context.path !== undefined) {\n                  _.set(\n                    res,\n                    context.path,\n                    _.isArray(value) ? [] : _.isPlainObject(value) ? {} : value\n                  );\n                } else {\n                  res = _.isArray(value)\n                    ? []\n                    : _.isPlainObject(value)\n                    ? {}\n                    : value;\n                }\n              }\n            }\n            return !reply.skipChildren;\n          } else {\n            // console.log('fc: ', context.path);\n            _.unset(res, context.path);\n\n            if (options.keepCircular) {\n              foundCircular.push([context.path, context.circularParent.path]);\n            }\n            return false;\n          }\n        } else if (context.afterIterate && !context.isCircular) {\n          // console.log('ai: ', context.path);\n          if (\n            curPath === undefined &&\n            rootReply.empty &&\n            !rootReply.keepIfEmpty\n          ) {\n            res = null;\n          } else if (\n            curPath !== undefined &&\n            replies[curPath].empty &&\n            !replies[curPath].keepIfEmpty\n          ) {\n            // console.log('remove ' + context.path);\n            _.unset(res, context.path);\n          } else {\n            _.eachRight(context.parents, function(parent) {\n              var p = pathToString(parent.path);\n              if (p !== undefined && replies[p].empty) {\n                replies[p].empty = false;\n              } else {\n                return false;\n              }\n            });\n            rootReply.empty = false;\n          }\n          // console.log('←', replies);\n          return;\n        }\n      },\n      eachDeepOptions\n    );\n    if (rootReply && rootReply.empty && !rootReply.keepIfEmpty) {\n      res = null;\n    }\n    _.each(foundCircular, function(c) {\n      var cv;\n      var found = c[1] === undefined || exists(res, c[1]);\n      if (!found) { return; }\n      // console.log('circular: ', c[0], c[1]);\n      if (_.has(options, 'replaceCircularBy')) {\n        cv = options.replaceCircularBy;\n      } else {\n        cv = obtain(res, c[1]);\n      }\n      _.set(res, c[0], cv);\n    });\n    if (options.condense) {\n      //console.log('filterDeep → condenseDeep');\n      res = condenseDeep(res, { checkCircular: options.checkCircular });\n    }\n    if (_.isArray(res) && !res.length && !eachDeepOptions.includeRoot)\n      { return null; }\n    return res;\n  }\n  return filterDeep;\n}\n\nmodule.exports = getFilterDeep;\n","'use strict';\n\nvar rxArrIndex = /^\\d+$/;\nvar rxVarName = /^[a-zA-Z_$]+([\\w_$]*)$/;\n\nfunction getPathToString(_) {\n  function pathToString(path) {\n    if (_.isString(path)) { return path; }\n    if (!_.isArray(path)) { return undefined; }\n    return _.reduce(\n      path,\n      function(accumulator, value) {\n        if (rxArrIndex.test(value)) {\n          return accumulator + '[' + value + ']';\n        }\n        if (rxVarName.test(value)) {\n          return accumulator + (accumulator ? '.' : '') + value;\n        }\n        return (\n          accumulator + '[\"' + value.toString().replace(/\"/g, '\\\\\"') + '\"]'\n        );\n      },\n      ''\n    );\n  }\n  return pathToString;\n}\n\ngetPathToString.notChainable = true;\n\nmodule.exports = getPathToString;\n","'use strict';\n\nvar getIterate = require('./private/getIterate.js');\n\nfunction getEachDeep(_) {\n  var iterate = getIterate(_);\n\n  function eachDeep(obj, callback, options) {\n    if (callback === undefined) { callback = _.identity; }\n    options = _.merge(\n      {\n        includeRoot: !_.isArray(obj),\n        pathFormat: 'string',\n        checkCircular: false,\n        leavesOnly: false,\n      },\n      options || {}\n    );\n    if (options.childrenPath !== undefined) {\n      if (!options.includeRoot && options.rootIsChildren === undefined) {\n        options.rootIsChildren = _.isArray(obj);\n      }\n      if (\n        !_.isString(options.childrenPath) &&\n        !_.isArray(options.childrenPath)\n      ) {\n        throw Error('childrenPath can be string or array');\n      } else {\n        if (_.isString(options.childrenPath)) {\n          options.childrenPath = [options.childrenPath];\n        }\n        for (var i = options.childrenPath.length - 1; i >= 0; i--) {\n          options.childrenPath[i] = _.toPath(options.childrenPath[i]);\n        }\n      }\n    }\n    iterate(\n      obj,\n      callback,\n      options,\n      undefined,\n      undefined,\n      0,\n      undefined,\n      [],\n      obj\n    );\n    return obj;\n  }\n  return eachDeep;\n}\n\nmodule.exports = getEachDeep;\n","import { parse as parseDate } from 'grafana/app/core/utils/datemath';\nimport { getRequestId, applyFilters, toGranularityWithLowerBound } from './utils';\nimport { parse } from './parser/events-assets';\nimport { formQueriesForExpression } from './parser/ts';\nimport { BackendSrv } from 'grafana/app/core/services/backend_srv';\nimport { TemplateSrv } from 'grafana/app/features/templating/template_srv';\nimport { appEvents } from 'grafana/app/core/core';\nimport {\n  CogniteDataSourceSettings,\n  DataQueryRequestItem,\n  DataQueryRequestResponse,\n  MetricFindQueryResponse,\n  QueryOptions,\n  QueryResponse,\n  QueryTarget,\n  Tab,\n  TimeSeriesResponseItem,\n  VariableQueryData,\n  HttpMethod,\n  DataQueryRequest,\n  ResponseMetadata,\n  isError,\n  Tuple,\n  MetaResponses,\n  FailResponse,\n  SuccessResponse,\n  InputQueryTarget,\n  AnnotationResponse,\n  AnnotationQueryOptions,\n  FilterRequest,\n  AssetsFilterRequestParams,\n  EventsFilterRequestParams,\n} from './types';\nimport {\n  formQueriesForTargets,\n  getTimeseries,\n  reduceTimeseries,\n  promiser,\n  getLimitsWarnings,\n  getCalculationWarnings,\n  datapointsPath,\n  stringifyError,\n  getLabelsForTarget,\n} from './cdfDatasource';\nimport { Connector } from './connector';\nimport { TimeRange } from '@grafana/ui';\nimport { ParsedFilter, QueryCondition } from './parser/types';\nimport { datapointsWarningEvent, failedResponseEvent, TIMESERIES_LIMIT_WARNING } from './constants';\n\nconst { Asset, Custom, Timeseries } = Tab;\nconst { POST } = HttpMethod;\n\nexport default class CogniteDatasource {\n  /**\n   * Parameters that are needed by grafana\n   */\n  id: number;\n  url: string;\n  name: string;\n\n  project: string;\n  connector: Connector;\n\n  /** @ngInject */\n  constructor(\n    instanceSettings: CogniteDataSourceSettings,\n    backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv\n  ) {\n    this.id = instanceSettings.id;\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    const { url, jsonData } = instanceSettings;\n    this.project = jsonData.cogniteProject;\n    this.connector = new Connector(jsonData.cogniteProject, url, backendSrv);\n  }\n\n  /**\n   * used by panels to get timeseries data\n   */\n  async query(options: QueryOptions): Promise<QueryResponse> {\n    const queryTargets = filterEmptyQueryTargets(options.targets);\n    let responseData = [];\n\n    if (queryTargets.length) {\n      try {\n        const { failed, succeded } = await this.fetchTimeseriesForTargets(queryTargets, options);\n        handleFailedTargets(failed);\n        showWarnings(succeded);\n        responseData = reduceTimeseries(succeded, getRange(options.range));\n      } catch (error) {\n        console.error(error); // not sure it ever happens\n      }\n    }\n\n    return { data: responseData };\n  }\n\n  async fetchTimeseriesForTargets(\n    queryTargets: QueryTarget[],\n    options: QueryOptions\n  ): Promise<MetaResponses> {\n    const itemsForTargetsPromises = queryTargets.map(async target => {\n      try {\n        const items = await this.getDataQueryRequestItems(target, options);\n        return { items, target };\n      } catch (e) {\n        handleError(e, target.refId);\n      }\n    });\n    const queryData = (await Promise.all(itemsForTargetsPromises)).filter(\n      data => data?.items?.length\n    );\n\n    const queries = formQueriesForTargets(queryData, options);\n    const metadata = await Promise.all(\n      queryData.map(async ({ target, items }) => {\n        let labels = [];\n        try {\n          labels = (await getLabelsForTarget(target, items, this.connector)).map(label =>\n            this.replaceVariable(label, options.scopedVars)\n          );\n        } catch (err) {\n          handleError(err, target.refId);\n        }\n        return { target, labels };\n      })\n    );\n\n    return promiser<DataQueryRequest, ResponseMetadata, DataQueryRequestResponse>(\n      queries,\n      metadata,\n      async (data, { target }) => {\n        const isSynthetic = data.items.some(q => !!q.expression);\n        const chunkSize = isSynthetic ? 10 : 100;\n\n        return this.connector.chunkAndFetch<DataQueryRequest, DataQueryRequestResponse>(\n          {\n            data,\n            path: datapointsPath(isSynthetic),\n            method: POST,\n            requestId: getRequestId(options, target),\n          },\n          chunkSize\n        );\n      }\n    );\n  }\n\n  private async getDataQueryRequestItems(\n    target: QueryTarget,\n    options: QueryOptions\n  ): Promise<DataQueryRequestItem[]> {\n    const { tab, target: tsId, assetQuery, expr } = target;\n    switch (tab) {\n      case undefined:\n      case Timeseries: {\n        return [{ id: tsId }];\n      }\n      case Asset: {\n        const timeseries = await this.findAssetTimeseries(target, options);\n        return timeseries.map(({ id }) => ({ id }));\n      }\n      case Tab.Custom: {\n        const templatedExpr = this.replaceVariable(expr, options.scopedVars);\n        const defaultInterval = toGranularityWithLowerBound(options.intervalMs);\n        return formQueriesForExpression(templatedExpr, target, this.connector, defaultInterval);\n      }\n    }\n  }\n\n  replaceVariable(query: string, scopedVars?): string {\n    return this.templateSrv.replace(query.trim(), scopedVars);\n  }\n\n  /**\n   * used by dashboards to get annotations (events)\n   */\n  async annotationQuery(options: AnnotationQueryOptions): Promise<AnnotationResponse[]> {\n    const {\n      range,\n      annotation,\n      annotation: { query, error },\n    } = options;\n    const [startTime, endTime] = getRange(range);\n\n    if (error || !query) {\n      return [];\n    }\n\n    const replacedVariablesQuery = this.replaceVariable(query);\n    const { filters, params } = parse(replacedVariablesQuery);\n    const timeFrame = {\n      startTime: { max: endTime },\n      endTime: { min: startTime },\n    };\n    const data: FilterRequest<EventsFilterRequestParams> = {\n      filter: { ...params, ...timeFrame },\n      limit: 1000,\n    };\n\n    const items = await this.connector.fetchItems<any>({\n      data,\n      path: `/events/list`,\n      method: POST,\n    });\n    const response = applyFilters(items, filters);\n\n    return response.map(({ description, startTime, endTime, type }) => ({\n      annotation,\n      isRegion: true,\n      text: description,\n      time: startTime,\n      timeEnd: endTime,\n      title: type,\n    }));\n  }\n\n  /**\n   * used by query editor to search for assets/timeseries\n   */\n  async getOptionsForDropdown(\n    query: string,\n    type?: string,\n    options?: any\n  ): Promise<MetricFindQueryResponse> {\n    const resources = {\n      [Tab.Asset]: 'assets',\n      [Tab.Timeseries]: 'timeseries',\n    };\n    const data: any = query\n      ? {\n          search: { query },\n        }\n      : {};\n\n    const items = await this.connector.fetchItems<TimeSeriesResponseItem>({\n      data,\n      path: `/${resources[type]}/search`,\n      method: POST,\n      params: options,\n    });\n\n    return items.map(({ name, externalId, id, description }) => {\n      const displayName = name || externalId;\n      return {\n        text: description ? `${displayName} (${description})` : displayName,\n        value: id.toString(),\n      };\n    });\n  }\n\n  async findAssetTimeseries(\n    { refId, assetQuery }: QueryTarget,\n    { scopedVars }: QueryOptions\n  ): Promise<TimeSeriesResponseItem[]> {\n    const assetId = this.replaceVariable(assetQuery.target, scopedVars);\n    const filter = assetQuery.includeSubtrees\n      ? {\n          assetSubtreeIds: [{ id: Number(assetId) }],\n        }\n      : {\n          assetIds: [assetId],\n        };\n\n    // since /dataquery can only have 100 items and checkboxes become difficult to use past 100 items,\n    //  we only get the first 100 timeseries, and show a warning if there are too many timeseries\n    const limit = 101;\n    const ts = await getTimeseries({ filter, limit }, this.connector);\n    if (ts.length === limit) {\n      appEvents.emit(datapointsWarningEvent, {\n        refId,\n        warning: TIMESERIES_LIMIT_WARNING,\n      });\n\n      ts.splice(-1);\n    }\n    return ts;\n  }\n\n  /**\n   * used by query editor to get metric suggestions (template variables)\n   */\n  async metricFindQuery({ query }: VariableQueryData): Promise<MetricFindQueryResponse> {\n    let params: QueryCondition;\n    let filters: ParsedFilter[];\n\n    try {\n      ({ params, filters } = parse(query));\n    } catch (e) {\n      return [];\n    }\n\n    const data: FilterRequest<AssetsFilterRequestParams> = {\n      filter: params,\n      limit: 1000,\n    };\n\n    const assets = await this.connector.fetchItems<any>({\n      data,\n      path: `/assets/list`,\n      method: POST,\n    });\n\n    const filteredAssets = applyFilters(assets, filters);\n\n    return filteredAssets.map(({ name, id }) => ({\n      text: name,\n      value: id,\n    }));\n  }\n\n  /**\n   * used by data source configuration page to make sure the connection is working\n   */\n  async testDatasource() {\n    const { status, data } = await this.connector.request({ path: 'cogniteloginstatus' });\n\n    if (status === 200) {\n      if (data.data.loggedIn && data.data.project === this.project) {\n        return {\n          status: 'success',\n          message: 'Your Cognite credentials are valid',\n          title: 'Success',\n        };\n      }\n      return {\n        status: 'error',\n        message: 'Your Cognite credentials are invalid',\n        title: 'Error',\n      };\n    }\n  }\n}\n\nexport function filterEmptyQueryTargets(targets: InputQueryTarget[]): QueryTarget[] {\n  return targets.filter(target => {\n    if (target && !target.hide) {\n      const { tab, assetQuery } = target;\n      switch (tab) {\n        case Asset:\n          return assetQuery && assetQuery.target;\n        case Custom:\n          return target.expr;\n        case Timeseries:\n        case undefined:\n          return target.target;\n      }\n    }\n  }) as QueryTarget[];\n}\n\nfunction handleFailedTargets(failed: FailResponse<ResponseMetadata>[]) {\n  failed\n    .filter(isError)\n    .filter(({ error }) => !error.cancelled) // if response was cancelled, no need to show error message\n    .forEach(({ error, metadata }) => handleError(error, metadata.target.refId));\n}\n\nexport function getRange(range: TimeRange): Tuple<number> {\n  const timeFrom = Math.ceil(parseDate(range.from));\n  const timeTo = Math.ceil(parseDate(range.to));\n  return [timeFrom, timeTo];\n}\n\nfunction handleError(error: any, refId: string) {\n  const errMessage = stringifyError(error);\n  appEvents.emit(failedResponseEvent, { refId, error: errMessage });\n}\n\nfunction showWarnings(responses: SuccessResponse<ResponseMetadata, DataQueryRequestResponse>[]) {\n  responses.forEach(({ result, metadata }) => {\n    const items = result.data.items;\n    const limit = result.config.data.limit;\n    const refId = metadata.target.refId;\n    const warning = [getLimitsWarnings(items, limit), getCalculationWarnings(items)]\n      .filter(Boolean)\n      .join('\\n');\n\n    if (warning) {\n      appEvents.emit(datapointsWarningEvent, { refId, warning });\n    }\n  });\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","import { STSClientFilter } from './ts';\n\nexport const FilterType = {\n  RegexNotEquals: '!~' as FilterType,\n  RegexEquals: '=~' as FilterType,\n  NotEquals: '!=' as FilterType,\n  Equals: '=' as FilterType,\n};\nexport type FilterType = '!~' | '=~' | '!=' | '=';\n\nexport enum QueryParserTypes {\n  assets = 'assets',\n  events = 'events',\n}\n\nexport interface QueryParserType {\n  type: QueryParserTypes;\n}\n\nexport interface QueryParserResponse extends QueryParserType {\n  query: QueryCondition[];\n}\n\nexport type ParsedFilter = STSClientFilter;\n\nexport interface QueryCondition {\n  [key: string]: any;\n}\n\nexport interface ParserResponse extends QueryParserType {\n  params: QueryCondition;\n  filters: ParsedFilter[];\n}\n","(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        function stringifySymbolSequence (e) {\n            return e.literal ? JSON.stringify(e.literal) :\n                   e.type ? '%' + e.type : e.toString();\n        }\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(stringifySymbolSequence).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                                 + \" ● \"\n                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n        return this.name + \" → \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n            var col = this.index - this.lastLineBreak;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += \"  \" + line + \"\\n\"\n            message += \"  \" + Array(col).join(\" \") + \"^\"\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n    }\n\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (token = lexer.next()) {\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var err = new Error(this.reportError(token));\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.reportError = function(token) {\n        var lines = [];\n        var tokenDisplay = (token.type ? token.type + \" token: \" : \"\") + JSON.stringify(token.value !== undefined ? token.value : token);\n        lines.push(this.lexer.formatError(token, \"Syntax error\"));\n        lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\\n');\n        var lastColumnIndex = this.table.length - 2;\n        var lastColumn = this.table[lastColumnIndex];\n        var expectantStates = lastColumn.states\n            .filter(function(state) {\n                var nextSymbol = state.rule.symbols[state.dot];\n                return nextSymbol && typeof nextSymbol !== \"string\";\n            });\n\n        // Display a \"state stack\" for each expectant state\n        // - which shows you how this state came to be, step by step.\n        // If there is more than one derivation, we only display the first one.\n        var stateStacks = expectantStates\n            .map(function(state) {\n                return this.buildFirstStateStack(state, []);\n            }, this);\n        // Display each state that is expecting a terminal symbol next.\n        stateStacks.forEach(function(stateStack) {\n            var state = stateStack[0];\n            var nextSymbol = state.rule.symbols[state.dot];\n            var symbolDisplay = this.getSymbolDisplay(nextSymbol);\n            lines.push('A ' + symbolDisplay + ' based on:');\n            this.displayStateStack(stateStack, lines);\n        }, this);\n\n        lines.push(\"\");\n        return lines.join(\"\\n\");\n    };\n\n    Parser.prototype.displayStateStack = function(stateStack, lines) {\n        var lastDisplay;\n        var sameDisplayCount = 0;\n        for (var j = 0; j < stateStack.length; j++) {\n            var state = stateStack[j];\n            var display = state.rule.toString(state.dot);\n            if (display === lastDisplay) {\n                sameDisplayCount++;\n            } else {\n                if (sameDisplayCount > 0) {\n                    lines.push('    ⬆ ︎' + sameDisplayCount + ' more lines identical to this');\n                }\n                sameDisplayCount = 0;\n                lines.push('    ' + display);\n            }\n            lastDisplay = display;\n        }\n    };\n\n    Parser.prototype.getSymbolDisplay = function(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\" && symbol.literal) {\n            return JSON.stringify(symbol.literal);\n        } else if (type === \"object\" && symbol instanceof RegExp) {\n            return 'character matching ' + symbol;\n        } else if (type === \"object\" && symbol.type) {\n            return symbol.type + ' token';\n        } else {\n            throw new Error('Unknown symbol type: ' + symbol);\n        }\n    };\n\n    /*\n    Builds a the first state stack. You can think of a state stack as the call stack\n    of the recursive-descent parser which the Nearley parse algorithm simulates.\n    A state stack is represented as an array of state objects. Within a\n    state stack, the first item of the array will be the starting\n    state, with each successive item in the array going further back into history.\n\n    This function needs to be given a starting state and an empty array representing\n    the visited states, and it returns an single state stack.\n\n    */\n    Parser.prototype.buildFirstStateStack = function(state, visited) {\n        if (visited.indexOf(state) !== -1) {\n            // Found cycle, return null\n            // to eliminate this path from the results, because\n            // we don't know how to display it meaningfully\n            return null;\n        }\n        if (state.wantedBy.length === 0) {\n            return [state];\n        }\n        var prevState = state.wantedBy[0];\n        var childVisited = [state].concat(visited);\n        var childResult = this.buildFirstStateStack(prevState, childVisited);\n        if (childResult === null) {\n            return null;\n        }\n        return [state].concat(childResult);\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n","import { DataQueryRequestItem, TimeSeriesResponseItem, QueryTarget, IdEither } from '../../types';\nimport _, { isArray, isObjectLike, uniqBy, findIndex, cloneDeep } from 'lodash';\nimport { Parser, Grammar } from 'nearley';\nimport grammar from './grammar';\nimport { getTimeseries, getLabelWithInjectedProps } from '../../cdfDatasource';\nimport { Connector } from '../../connector';\nimport { FilterType } from '../types';\nimport { applyFilters } from '../../utils';\nimport { parseWith } from '../events-assets/index';\nimport getFilterDeep from 'deepdash/getFilterDeep';\n\nconst filterDeep = getFilterDeep(_);\nconst compiledGrammar = Grammar.fromCompiled(grammar);\n\nexport const formQueriesForExpression = async (\n  expression: string,\n  target: QueryTarget,\n  connector: Connector,\n  defaultInterval: string\n): Promise<DataQueryRequestItem[]> => {\n  const rawParsed = parse(expression);\n  const { aggregation, granularity } = target;\n  const parsed = enrichWithDefaultAggregates(\n    rawParsed,\n    { granularity, aggregate: aggregation },\n    defaultInterval\n  );\n  const serverFilters = getServerFilters(parsed);\n  if (!serverFilters.length) {\n    return [{ expression: composeSTSQuery(parsed) }];\n  }\n  const timeseries = await Promise.all(\n    serverFilters.map(async filter => {\n      const tsResult = await getTimeseries({ filter }, connector, false);\n      if (!tsResult.length) {\n        throw NoTimeseriesFound(filter, expression);\n      }\n      return tsResult;\n    })\n  );\n  const clientFilters = getClientFilters(parsed);\n  const clientFilteredTimeseries = timeseries.map((arr, i) => applyFilters(arr, clientFilters[i]));\n  const multiaryFuncTsIndices = getIndicesOfMultiaryFunctionArgs(parsed);\n  const permutations = generateAllPossiblePermutations(\n    clientFilteredTimeseries,\n    multiaryFuncTsIndices\n  );\n  const queryExpressions = permutations.map(series => injectTSIdsInExpression(parsed, series));\n  return queryExpressions.map(expression => ({ expression }));\n};\n\nconst NoTimeseriesFound = (filter: StringMap, expr: string) => {\n  return new Error(\n    `No timeseries found for filter ${JSON.stringify(filter)} in expression ${expr}`\n  );\n};\n\n/**\n * Injects default values of aggregate and granularity (if it is not provided).s\n * @param parsedData: synthetic timeseries parsed data\n * @param target: {aggregation, granularity}\n * @param defaultInterval – interval that comes from grafana options\n * @return result – parsed data with default values of aggregation and granularity\n */\nexport const enrichWithDefaultAggregates = (\n  parsedData: STSQuery,\n  { aggregate, granularity }: { aggregate: string; granularity: string },\n  defaultInterval: string\n) => {\n  if (aggregate === 'none') {\n    return parsedData;\n  }\n\n  const result = cloneDeep(parsedData);\n  const defaultValues = {\n    aggregate,\n    granularity: granularity || defaultInterval,\n  };\n  walk(result, obj => {\n    if (isSTSReference(obj)) {\n      Object.keys(defaultValues).forEach(key => {\n        if (findIndex(obj.query, ['path', key]) === -1) {\n          obj.query.push(STSFilter(key, defaultValues[key]));\n        }\n      });\n    }\n  });\n\n  return result;\n};\n\nexport const injectTSIdsInExpression = (\n  parsedData: STSQuery,\n  timeseries: TimeSeriesResponseItem[][]\n) => {\n  let i = 0;\n  const exprWithSum = composeSTSQuery(parsedData, item => {\n    if (isSTSReference(item) && !hasIdsFilter(item)) {\n      const syntheticFilters = item.query.filter(isSTSAggregateFilter);\n      const paramTSIds = timeseries[i++].map(({ id }) => id);\n      const pseudoParsedSTS = paramTSIds.map(id =>\n        STSReference([STSFilter('id', id), ...syntheticFilters])\n      );\n      return pseudoParsedSTS.map(ts => composeSTSQuery(ts)).join(', ');\n    }\n  });\n  return flattenSumFunctions(exprWithSum);\n};\n\nexport const parse = (s: string): STSQuery => {\n  return parseWith(new Parser(compiledGrammar), s);\n};\n\nexport const generateAllPossiblePermutations = <T>(\n  arrayOfArrays: T[][],\n  lockIndices: number[] = []\n): T[][][] => {\n  let res: T[][][] = [];\n  for (let i = 0; i < arrayOfArrays.length; i++) {\n    const locked = lockIndices.includes(i);\n    const array = [...arrayOfArrays[i]];\n    if (res.length) {\n      const temp = [...res];\n      const temptemp = [];\n      for (const t of temp) {\n        if (locked) {\n          temptemp.push([...t, array]);\n        } else {\n          for (const item of array) {\n            temptemp.push([...t, [item]]);\n          }\n        }\n      }\n      res = [...temptemp];\n    } else {\n      if (locked) {\n        res = [[array]];\n      } else {\n        res = array.map(i => [[i]]);\n      }\n    }\n  }\n  return res;\n};\n\nexport const convertExpressionToLabel = (\n  expression: string,\n  labelSrc: string,\n  tsMap: TSResponseMap\n) => {\n  return composeSTSQuery(parse(expression), item => {\n    if (isSTSReference(item)) {\n      const [{ value }] = getIdFilters(item);\n      const serie = tsMap[String(value)];\n      if (labelSrc) {\n        return getLabelWithInjectedProps(labelSrc, serie);\n      }\n      return `${serie.name || serie.externalId || serie.id}`;\n    }\n  });\n};\n\nexport const getLabelsForExpression = async (\n  expressions: string[],\n  labelSrc: string,\n  connector: Connector\n) => {\n  const tsIds = getReferencedIdsInExpressions(expressions);\n  const tsUniqueIds = uniqBy(tsIds, unwrapId);\n  const referencedTS = await getTimeseries({ items: tsUniqueIds }, connector, false);\n  const tsMap = reduceTsToMap(referencedTS);\n  return expressions.map(expr => convertExpressionToLabel(expr, labelSrc, tsMap));\n};\n\nexport const getReferencedTimeseries = (route: STSQuery): StringMap[] => {\n  let idFilters: STSServerFilter[] = [];\n  walk(route, obj => {\n    if (isSTSReference(obj)) {\n      const ids = getIdFilters(obj);\n      idFilters = [...idFilters, ...ids];\n    }\n  });\n  return idFilters.map(({ path, value }) => ({\n    [path]: value as string,\n  }));\n};\n\nexport const hasAggregates = (expression: string): boolean => {\n  let hasAggregates = false;\n  walk(parse(expression), obj => {\n    if (isSTSReference(obj) && obj.query.some(isSTSAggregateFilter)) {\n      hasAggregates = true;\n    }\n  });\n  return hasAggregates;\n};\n\nexport const flattenServerQueryFilters = (items: unknown[]): StringMap => {\n  return items.filter(isSTSFilter).reduce((res, filter) => {\n    let value: any;\n    if (isByIdsQuery(filter.value)) {\n      value = filter.value.map(item => flattenServerQueryFilters([item]));\n    } else if (isSTSFilterArr(filter.value)) {\n      value = { ...res[filter.path], ...flattenServerQueryFilters(filter.value) };\n    } else if (isSTSFilterArr2d(filter.value)) {\n      value = filter.value.map(flattenServerQueryFilters);\n    } else {\n      value = filter.value;\n    }\n    res[filter.path] = value;\n    return res;\n  }, {});\n};\n\nexport const walk = (route: STSQuery, iterator: (item: STSQueryItem | STSFunction) => void) => {\n  if (isArray(route)) {\n    route.forEach(r => walk(r, iterator));\n  } else {\n    iterator(route);\n    if (isSTSFunction(route)) {\n      walk(isMapFunction(route) ? route.args[0] : route.args, iterator);\n    }\n  }\n};\n\nexport const getIndicesOfMultiaryFunctionArgs = (route: STSQuery): number[] => {\n  const responseArr = [];\n  const argsIndices = [];\n  let index = 0;\n  walk(route, obj => {\n    if (isMultiaryFunction(obj) && obj.args.length === 1) {\n      argsIndices.push(...obj.args);\n    } else if (isSTSReference(obj) && !hasIdsFilter(obj)) {\n      if (argsIndices.includes(obj)) {\n        responseArr.push(index);\n      }\n      index++;\n    }\n  });\n  return responseArr;\n};\n\nexport const extractFilters = (\n  route: STSQuery,\n  condition: (_, __, parent) => boolean\n): unknown[][] => {\n  const extracted: unknown[][] = [];\n  walk(route, obj => {\n    if (isSTSReference(obj) && !hasIdsFilter(obj)) {\n      extracted.push(filterDeep(obj.query, condition));\n    }\n  });\n  return extracted;\n};\n\nexport const getServerFilters = (route: STSQuery): StringMap[] => {\n  const filter = (_, __, parent) => isServerFilter(parent) || !isSTSFilter(parent);\n  return extractFilters(route, filter).map(filters =>\n    flattenServerQueryFilters(filters || [])\n  ) as StringMap[];\n};\n\nexport const flattenClientQueryFilters = (filters: unknown[], path = []): STSClientFilter[] => {\n  const res: STSClientFilter[] = [];\n  filters.filter(isSTSFilter).forEach(filter => {\n    if (isServerFilter(filter) && isSTSFilterArr(filter.value)) {\n      res.push(...flattenClientQueryFilters(filter.value, [...path, filter.path]));\n    } else {\n      res.push({\n        path: [...path, filter.path].join('.'),\n        value: filter.value,\n        filter: filter.filter,\n      } as STSClientFilter);\n    }\n  });\n  return res;\n};\n\nexport const getClientFilters = (route: STSQuery): STSClientFilter[][] => {\n  const filter = (_, __, parent) => isClientFilter(parent) || isArray(parent.value);\n  return extractFilters(route, filter).map(filters =>\n    flattenClientQueryFilters(filters || [])\n  ) as STSClientFilter[][];\n};\n\nconst reverseSTSFilter = ({ path, filter, value }: STSFilter) => {\n  return `${path}${filter}${stringifyValue(value)}`;\n};\n\nconst stringifyValue = (val: STSValue, wrap: boolean = true) => {\n  if (isArray(val)) {\n    const items = (val as any).map(item => {\n      return isSTSFilter(item) ? reverseSTSFilter(item) : stringifyValue(item);\n    });\n    const joinedStr = items.join(', ');\n    if (wrap) {\n      return isSTSFilterArr(val) ? `{${joinedStr}}` : `[${joinedStr}]`;\n    }\n    return joinedStr;\n  }\n  return JSON.stringify(val);\n};\n\nexport const composeSTSQuery = (\n  target: STSQuery,\n  custom?: (item: STSQuery) => string,\n  separateWith: string = ''\n): string => {\n  if (custom) {\n    const customRes = custom(target);\n    if (customRes !== undefined) {\n      return customRes;\n    }\n  }\n  if (isArray(target)) {\n    return target.map(i => composeSTSQuery(i, custom)).join(separateWith);\n  }\n  if (isSTSReference(target)) {\n    return `${target.type}{${stringifyValue(target.query, false)}}`;\n  }\n  if (isOperator(target)) {\n    return ` ${target.operator} `;\n  }\n  if (isWrappedConst(target)) {\n    return `${target.constant}`;\n  }\n  const separator = isMultiaryFunction(target) ? ', ' : '';\n  let stringArgs = '';\n  if (isMapFunction(target)) {\n    const [arg0, ...args] = target.args;\n    stringArgs = `${composeSTSQuery(arg0, custom)}, ${args\n      .map(arg => stringifyValue(arg))\n      .join(', ')}`;\n  } else {\n    stringArgs = composeSTSQuery(target.args, custom, separator);\n  }\n  return `${target.func}(${stringArgs})`;\n};\n\nconst flattenSumFunctions = (expression: string): string => {\n  return composeSTSQuery(parse(expression), item => {\n    if (isSumFunction(item)) {\n      return `(${composeSTSQuery(item.args, null, ' + ')})`;\n    }\n  });\n};\n\nconst isSimpleSyntheticExpression = (expr: string): boolean => {\n  const parsed = parse(expr);\n  return !getServerFilters(parsed).length;\n};\n\nconst unwrapId = (idEither: IdEither) => {\n  if ('id' in idEither) {\n    return idEither.id;\n  }\n  return idEither.externalId;\n};\n\nconst getReferencedIdsInExpressions = (expressions: string[]) => {\n  const allIds: IdEither[] = [];\n  for (const expression of expressions) {\n    const parsed = parse(expression);\n    const referenced = getReferencedTimeseries(parsed) as IdEither[];\n    allIds.push(...referenced);\n  }\n  return allIds;\n};\n\nconst reduceTsToMap = (timeseries: TimeSeriesResponseItem[]): TSResponseMap => {\n  return timeseries.reduce((map, serie) => {\n    map[serie.id] = serie;\n    if (serie.externalId) {\n      map[serie.externalId] = serie;\n    }\n    return map;\n  }, {} as TSResponseMap);\n};\n\nexport const STSReference = (query: STSFilter[] = []): STSReference => {\n  return {\n    query,\n    type: 'ts',\n  };\n};\n\nexport const STSFilter = (\n  path: string,\n  value: STSFilter['value'],\n  filter: FilterType = '='\n): STSFilter => {\n  return { path, value, filter } as STSFilter;\n};\n\nexport const Operator = (operator: Operator['operator']): Operator => {\n  return { operator };\n};\n\nexport const Constant = (constant: number): WrappedConst => {\n  return { constant };\n};\n\nconst getIdFilters = (obj: STSReference) => {\n  return obj.query.filter(isIdsFilter);\n};\n\nconst hasIdsFilter = (obj: STSReference) => {\n  return getIdFilters(obj).length;\n};\n\nconst isEqualsFilter = (query: any): query is STSServerFilter => {\n  return isSTSFilter(query) && query.filter === FilterType.Equals;\n};\n\nconst isOneOf = (value: string, ...arr: string[]) => {\n  return arr.indexOf(value) !== -1;\n};\n\nconst isSTSAggregateFilter = (query: STSFilter) => {\n  return isEqualsFilter(query) && isOneOf(query.path, 'granularity', 'aggregate');\n};\n\nconst isIdsFilter = (query: STSFilter): query is STSServerFilter => {\n  return isEqualsFilter(query) && isOneOf(query.path, 'id', 'externalId');\n};\n\nconst isServerFilter = (item: STSFilter): item is STSServerFilter => {\n  return isEqualsFilter(item) && !isSTSAggregateFilter(item);\n};\n\nconst isClientFilter = (item: any): item is STSClientFilter => {\n  return isSTSFilter(item) && !isEqualsFilter(item);\n};\n\nconst isByIdsQuery = (query: any): query is STSFilter[] => {\n  return isArray(query) && query.some(isIdsFilter);\n};\n\nconst isSTSFilter = (item: any): item is STSFilter => {\n  return isObjectLike(item) && item.path && item.filter && 'value' in item;\n};\n\nconst isSTSFilterArr = (query: any): query is STSFilter[] => {\n  return isArray(query) && query.length && query.every(isSTSFilter);\n};\n\nconst isSTSFilterArr2d = (query: any): query is STSFilter[][] => {\n  return isArray(query) && query.every(isSTSFilterArr);\n};\n\nconst isWrappedConst = (obj: any): obj is WrappedConst => {\n  return isObjectLike(obj) && 'constant' in obj;\n};\n\nconst isSTSReference = (obj: any): obj is STSReference => {\n  return isObjectLike(obj) && obj.type === 'ts';\n};\n\nconst isOperator = (obj: any): obj is Operator => {\n  return isObjectLike(obj) && 'operator' in obj;\n};\n\nconst isSTSFunction = (obj: any): obj is STSFunction => {\n  return isObjectLike(obj) && 'args' in obj && 'func' in obj;\n};\n\nconst isSpecificFunction = (obj: any, name: string): obj is STSFunction => {\n  return isSTSFunction(obj) && name === obj.func;\n};\n\nconst isMapFunction = (obj: any): obj is MapFunction => {\n  return isSpecificFunction(obj, 'map');\n};\n\nconst isSumFunction = (obj: any): obj is MultiaryFunction => {\n  return isSpecificFunction(obj, 'sum');\n};\n\nconst isMultiaryFunction = (obj: any): obj is MultiaryFunction => {\n  return (\n    isSTSFunction(obj) && isOneOf(obj.func, 'avg', 'sum', 'min', 'max', 'pow', 'round', 'on_error')\n  );\n};\n\ntype TSResponseMap = { [s: string]: TimeSeriesResponseItem };\n\ntype StringMap = { [key: string]: string };\n\ntype STSValue = STSPrimitiveValue | STSPrimitiveValue[] | STSFilter[] | STSFilter[][];\n\ntype STSPrimitiveValue = string | number | boolean;\n\nexport type STSQuery = (STSQueryItem[] | STSQueryItem)[] | STSQueryItem;\n\nexport type STSFilter = STSClientFilter | STSServerFilter;\n\nexport type STSClientFilter = {\n  path: string;\n  filter: Exclude<FilterType, '='>;\n  value: STSPrimitiveValue;\n};\n\nexport type STSServerFilter = {\n  path: string;\n  filter: FilterType;\n  value: STSValue;\n};\n\nexport type Operator = {\n  operator: '+' | '-' | '/' | '*';\n};\n\nexport type STSQueryItem = Operator | STSReference | WrappedConst | STSFunction;\n\nexport type WrappedConst = {\n  constant: number | 'pi()';\n};\n\nexport type STSFunction = UnaryFunction | MultiaryFunction | MapFunction;\n\nexport type UnaryFunction = {\n  func: 'sin' | 'cos' | 'ln' | 'sqrt' | 'exp' | 'abs' | '';\n  args: STSQueryItem[];\n};\n\nexport type MultiaryOperator = 'avg' | 'max' | 'min' | 'sum';\n\nexport type BinaryOperator = 'pow' | 'round' | 'on_error';\n\nexport type MultiaryFunction = {\n  func: MultiaryOperator | BinaryOperator;\n  args: (STSQueryItem[] | STSQueryItem)[];\n};\n\nexport type MapFunction = {\n  func: 'map';\n  args: [STSReference, string[], number[], number];\n};\n\nexport type STSReference = {\n  type: 'ts';\n  query: STSFilter[];\n};\n","import {\n  Tab,\n  QueryTarget,\n  DataQueryRequest,\n  DataQueryRequestItem,\n  QueryOptions,\n  TimeSeriesResponseItem,\n  HttpMethod,\n  TimeseriesFilterQuery,\n  TimeSeriesDatapoint,\n  Timestamp,\n  DataQueryRequestResponse,\n  ResponseMetadata,\n  Aggregates,\n  Granularity,\n  Tuple,\n  QueriesData,\n  SuccessResponse,\n  Responses,\n  IdEither,\n  Items,\n  Datapoint,\n} from './types';\nimport { get, cloneDeep } from 'lodash';\nimport { toGranularityWithLowerBound } from './utils';\nimport { Connector } from './connector';\nimport { getLabelsForExpression } from './parser/ts';\nimport { getRange } from './datasource';\nimport { TimeSeries } from '@grafana/ui';\nimport { CacheTime, DATAPOINTS_LIMIT_WARNING } from './constants';\n\nconst { Asset, Custom, Timeseries } = Tab;\nconst variableLabelRegex = /{{([^{}]+)}}/g;\n\nexport function formQueryForItems(\n  items,\n  { tab, aggregation, granularity },\n  options\n): DataQueryRequest {\n  const [start, end] = getRange(options.range);\n  if (tab === Custom) {\n    const limit = calculateDPLimitPerQuery(items.length);\n    return {\n      items: items.map(({ expression }) => ({ expression, start, end, limit })),\n    };\n  }\n  let aggregations: Aggregates & Granularity = null;\n  const isAggregated = aggregation && aggregation !== 'none';\n  if (isAggregated) {\n    aggregations = {\n      aggregates: [aggregation],\n      granularity: granularity || toGranularityWithLowerBound(options.intervalMs),\n    };\n  }\n  const limit = calculateDPLimitPerQuery(items.length, isAggregated);\n  return {\n    ...aggregations,\n    end,\n    start,\n    items,\n    limit,\n  };\n}\n\nfunction calculateDPLimitPerQuery(queriesNumber: number, hasAggregates: boolean = true) {\n  return Math.floor((hasAggregates ? 10_000 : 100_000) / Math.min(queriesNumber, 100));\n}\n\nexport function formQueriesForTargets(\n  queriesData: QueriesData,\n  options: QueryOptions\n): DataQueryRequest[] {\n  return queriesData.map(({ target, items }) => {\n    return formQueryForItems(items, target, options);\n  });\n}\n\nexport async function getLabelsForTarget(\n  target: QueryTarget,\n  queryList: DataQueryRequestItem[],\n  connector: Connector\n): Promise<string[]> {\n  const labelSrc = target.label || '';\n  switch (target.tab) {\n    case undefined:\n    case Timeseries: {\n      return [await getTimeseriesLabel(labelSrc, target.target, connector)];\n    }\n    case Asset: {\n      const tsIds = queryList.map(({ id }) => ({ id }));\n      /**\n       * TODO: While this is ok perfomence-wise as we have caching, it is not very nice code here.\n       * We should refactor labels logic someday\n       */\n      const timeseries = await getTimeseries({ items: tsIds }, connector, false);\n      return timeseries.map(ts => getLabelWithInjectedProps(labelSrc, ts));\n    }\n    case Custom: {\n      if (!labelSrc || labelContainsVariableProps(labelSrc)) {\n        const expressions = queryList.map(({ expression }) => expression);\n        return getLabelsForExpression(expressions, labelSrc, connector);\n      }\n      return queryList.map(() => labelSrc);\n    }\n  }\n}\n\nasync function getTimeseriesLabel(\n  label: string,\n  id: number,\n  connector: Connector\n): Promise<string> {\n  let resLabel = label;\n  if (label && labelContainsVariableProps(label)) {\n    const [ts] = await getTimeseries({ items: [{ id }] }, connector);\n    resLabel = getLabelWithInjectedProps(label, ts);\n  }\n  return resLabel;\n}\n\n// injects prop values to ts label, ex. `{{description}} {{metadata.key1}}` -> 'tsDescription tsMetadataKey1Value'\nexport function getLabelWithInjectedProps(\n  label: string,\n  timeseries: TimeSeriesResponseItem\n): string {\n  // matches with any text within {{ }}\n  return label.replace(variableLabelRegex, (full, group) => get(timeseries, group, full));\n}\n\nexport function labelContainsVariableProps(label: string): boolean {\n  return label && !!label.match(variableLabelRegex);\n}\n\nexport async function getTimeseries(\n  data: TimeseriesFilterQuery | Items<IdEither>,\n  connector: Connector,\n  filterIsString: boolean = true\n): Promise<TimeSeriesResponseItem[]> {\n  const method = HttpMethod.POST;\n  let items: TimeSeriesResponseItem[];\n\n  if ('items' in data) {\n    items = await connector.fetchItems({\n      data,\n      method,\n      path: `/timeseries/byids`,\n      cacheTime: CacheTime.TimeseriesByIds,\n    });\n  } else {\n    items = await connector.fetchAndPaginate({\n      data,\n      method,\n      path: `/timeseries/list`,\n      cacheTime: CacheTime.TimeseriesList,\n    });\n  }\n\n  return cloneDeep(filterIsString ? items.filter(ts => !ts.isString) : items);\n}\n\nexport function stringifyError(error: any) {\n  const { data, status } = error;\n  const errorMessage = data?.error?.message || error.message;\n  const errorCode = status ? `${status} ` : '';\n  return errorMessage ? `[${errorCode}ERROR] ${errorMessage}` : `Unknown error`;\n}\n\nexport function reduceTimeseries(\n  metaResponses: SuccessResponse<ResponseMetadata, DataQueryRequestResponse>[],\n  [start, end]: Tuple<number>\n): TimeSeries[] {\n  const responseTimeseries: TimeSeries[] = [];\n\n  metaResponses.forEach(({ result, metadata }) => {\n    const { labels } = metadata;\n    const { aggregates } = result.config.data;\n    const { items } = result.data;\n    const aggregateStr = aggregates ? `${aggregates} ` : '';\n\n    const series = items.map(({ datapoints, externalId, id }, i) => {\n      const label = labels && labels[i];\n      const resTarget = label || `${aggregateStr}${externalId || id}`;\n      const filteredDatapoints = (datapoints as Timestamp[]).filter(\n        ({ timestamp }) => timestamp >= start && timestamp <= end\n      );\n      const rawDatapoints = datapoints2Tuples(filteredDatapoints, aggregates);\n      return {\n        target: resTarget,\n        datapoints: rawDatapoints,\n      };\n    });\n\n    responseTimeseries.push(...series);\n  });\n\n  return responseTimeseries;\n}\n\nexport function datapoints2Tuples<T extends Timestamp[]>(\n  datapoints: T,\n  aggregate: string\n): Tuple<number>[] {\n  return datapoints.map(d => datapoint2Tuple(d, aggregate));\n}\n\nfunction datapoint2Tuple(\n  dp: Timestamp | TimeSeriesDatapoint,\n  aggregateProp: string\n): Tuple<number> {\n  const value = aggregateProp in dp ? dp[aggregateProp] : (dp as TimeSeriesDatapoint).value;\n  return [value, dp.timestamp];\n}\n\nexport async function promiser<Query, Metadata, Response>(\n  queries: Query[],\n  metadatas: Metadata[],\n  toPromise: (query: Query, metadata: Metadata) => Promise<Response>\n): Promise<Responses<Metadata, Response>> {\n  const succeded = [];\n  const failed = [];\n  const promises = queries.map(async (query, i) => {\n    const metadata = metadatas[i];\n    try {\n      const result = await toPromise(query, metadata);\n      succeded.push({ result, metadata });\n    } catch (error) {\n      failed.push({ error, metadata });\n    }\n  });\n  await Promise.all(promises);\n  return {\n    succeded,\n    failed,\n  };\n}\n\nexport function getLimitsWarnings(items: Datapoint[], limit: number) {\n  const hasMorePoints = items.some(({ datapoints }) => datapoints.length >= limit);\n  return hasMorePoints ? DATAPOINTS_LIMIT_WARNING : '';\n}\n\nexport function getCalculationWarnings(items: Datapoint[]) {\n  const datapointsErrors = new Set<string>();\n\n  items.forEach(({ datapoints }) => {\n    (datapoints as [])\n      .map(({ error }) => error)\n      .filter(Boolean)\n      .forEach(error => {\n        datapointsErrors.add(error);\n      });\n  });\n\n  return Array.from(datapointsErrors).join('\\n');\n}\n\nexport function datapointsPath(isSynthetic: boolean) {\n  return `/timeseries/${isSynthetic ? 'synthetic/query' : 'data/list'}`;\n}\n","import CogniteDatasource from './datasource';\nimport { CogniteQueryCtrl } from './query_ctrl';\nimport { CogniteConfigCtrl } from './config_ctrl';\nimport { CogniteAnnotationsQueryCtrl } from './annotation_ctrl';\nimport { CogniteVariableQueryCtrl } from './variable_query_ctrl';\n\nexport {\n  CogniteDatasource as Datasource,\n  CogniteQueryCtrl as QueryCtrl,\n  CogniteConfigCtrl as ConfigCtrl,\n  CogniteAnnotationsQueryCtrl as AnnotationsQueryCtrl,\n  CogniteVariableQueryCtrl as VariableQueryEditor,\n};\n","'use strict';\nconst strictUriEncode = require('strict-uri-encode');\nconst decodeComponent = require('decode-uri-component');\nconst splitOnFirst = require('split-on-first');\n\nfunction encoderForArrayFormat(options) {\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tconst index = result.length;\n\t\t\t\tif (value === undefined || (options.skipNull && value === null)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[', index, ']'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')\n\t\t\t\t];\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === undefined || (options.skipNull && value === null)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[]'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '[]=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'comma':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === null || value === undefined || value.length === 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (result.length === 0) {\n\t\t\t\t\treturn [[encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [[result, encode(value, options)].join(',')];\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === undefined || (options.skipNull && value === null)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, encode(key, options)];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(options) {\n\tlet result;\n\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'comma':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = typeof value === 'string' && value.split('').indexOf(',') > -1;\n\t\t\t\tconst newValue = isArray ? value.split(',') : value;\n\t\t\t\taccumulator[key] = newValue;\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction encode(value, options) {\n\tif (options.encode) {\n\t\treturn options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction decode(value, options) {\n\tif (options.decode) {\n\t\treturn decodeComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t}\n\n\tif (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input))\n\t\t\t.sort((a, b) => Number(a) - Number(b))\n\t\t\t.map(key => input[key]);\n\t}\n\n\treturn input;\n}\n\nfunction removeHash(input) {\n\tconst hashStart = input.indexOf('#');\n\tif (hashStart !== -1) {\n\t\tinput = input.slice(0, hashStart);\n\t}\n\n\treturn input;\n}\n\nfunction getHash(url) {\n\tlet hash = '';\n\tconst hashStart = url.indexOf('#');\n\tif (hashStart !== -1) {\n\t\thash = url.slice(hashStart);\n\t}\n\n\treturn hash;\n}\n\nfunction extract(input) {\n\tinput = removeHash(input);\n\tconst queryStart = input.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\n\treturn input.slice(queryStart + 1);\n}\n\nfunction parseValue(value, options) {\n\tif (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\tvalue = Number(value);\n\t} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n\t\tvalue = value.toLowerCase() === 'true';\n\t}\n\n\treturn value;\n}\n\nfunction parse(input, options) {\n\toptions = Object.assign({\n\t\tdecode: true,\n\t\tsort: true,\n\t\tarrayFormat: 'none',\n\t\tparseNumbers: false,\n\t\tparseBooleans: false\n\t}, options);\n\n\tconst formatter = parserForArrayFormat(options);\n\n\t// Create an object with no prototype\n\tconst ret = Object.create(null);\n\n\tif (typeof input !== 'string') {\n\t\treturn ret;\n\t}\n\n\tinput = input.trim().replace(/^[?#&]/, '');\n\n\tif (!input) {\n\t\treturn ret;\n\t}\n\n\tfor (const param of input.split('&')) {\n\t\tlet [key, value] = splitOnFirst(options.decode ? param.replace(/\\+/g, ' ') : param, '=');\n\n\t\t// Missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tvalue = value === undefined ? null : decode(value, options);\n\t\tformatter(decode(key, options), value, ret);\n\t}\n\n\tfor (const key of Object.keys(ret)) {\n\t\tconst value = ret[key];\n\t\tif (typeof value === 'object' && value !== null) {\n\t\t\tfor (const k of Object.keys(value)) {\n\t\t\t\tvalue[k] = parseValue(value[k], options);\n\t\t\t}\n\t\t} else {\n\t\t\tret[key] = parseValue(value, options);\n\t\t}\n\t}\n\n\tif (options.sort === false) {\n\t\treturn ret;\n\t}\n\n\treturn (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {\n\t\tconst value = ret[key];\n\t\tif (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(value);\n\t\t} else {\n\t\t\tresult[key] = value;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = (object, options) => {\n\tif (!object) {\n\t\treturn '';\n\t}\n\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none'\n\t}, options);\n\n\tconst formatter = encoderForArrayFormat(options);\n\n\tconst objectCopy = Object.assign({}, object);\n\tif (options.skipNull) {\n\t\tfor (const key of Object.keys(objectCopy)) {\n\t\t\tif (objectCopy[key] === undefined || objectCopy[key] === null) {\n\t\t\t\tdelete objectCopy[key];\n\t\t\t}\n\t\t}\n\t}\n\n\tconst keys = Object.keys(objectCopy);\n\n\tif (options.sort !== false) {\n\t\tkeys.sort(options.sort);\n\t}\n\n\treturn keys.map(key => {\n\t\tconst value = object[key];\n\n\t\tif (value === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn encode(key, options);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\treturn value\n\t\t\t\t.reduce(formatter(key), [])\n\t\t\t\t.join('&');\n\t\t}\n\n\t\treturn encode(key, options) + '=' + encode(value, options);\n\t}).filter(x => x.length > 0).join('&');\n};\n\nexports.parseUrl = (input, options) => {\n\treturn {\n\t\turl: removeHash(input).split('?')[0] || '',\n\t\tquery: parse(extract(input), options)\n\t};\n};\n\nexports.stringifyUrl = (input, options) => {\n\tconst url = removeHash(input.url).split('?')[0] || '';\n\tconst queryFromUrl = exports.extract(input.url);\n\tconst parsedQueryFromUrl = exports.parse(queryFromUrl);\n\tconst hash = getHash(input.url);\n\tconst query = Object.assign(parsedQueryFromUrl, input.query);\n\tlet queryString = exports.stringify(query, options);\n\tif (queryString) {\n\t\tqueryString = `?${queryString}`;\n\t}\n\n\treturn `${url}${queryString}${hash}`;\n};\n","'use strict';\nmodule.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","'use strict';\n\nmodule.exports = (string, separator) => {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (separator === '') {\n\t\treturn [string];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [string];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n};\n","'use strict';\n\nvar getPathToString = require('../getPathToString.js');\nvar getHasChildren = require('./getHasChildren.js');\n\nfunction getIterate(_) {\n  var pathToString = getPathToString(_);\n  var hasChildren = getHasChildren(_);\n  var _each = _.each || _.forArray;\n  function iterate(\n    value,\n    callback,\n    options,\n    key,\n    path,\n    depth,\n    parent,\n    parents,\n    obj,\n    childrenPath\n  ) {\n    if (options['break']) { return; }\n    var currentObj = {\n      value: value,\n      key: key,\n      path: options.pathFormat == 'array' ? path : pathToString(path),\n      parent: parent,\n    };\n\n    var currentParents = parents.concat( [currentObj]);\n\n    var isCircular = undefined;\n    var circularParentIndex = undefined;\n    var circularParent = undefined;\n    if (options.checkCircular) {\n      if (_.isObject(value) && !_.isEmpty(value)) {\n        circularParentIndex = _.findIndex(parents, function(v) {\n          return v.value === value;\n        });\n        circularParent = parents[circularParentIndex] || null;\n      } else {\n        circularParentIndex = -1;\n        circularParent = null;\n      }\n      isCircular = circularParentIndex !== -1;\n    }\n    var res;\n    var isLeaf =\n      !_.isObject(value) ||\n      _.isEmpty(value) ||\n      isCircular ||\n      (options.childrenPath !== undefined &&\n        !hasChildren(value, options.childrenPath));\n    var needCallback =\n      (depth || options.includeRoot) && (!options.leavesOnly || isLeaf);\n    // console.log('needCallback?', needCallback);\n    if (needCallback) {\n      var context = {\n        path: options.pathFormat == 'array' ? path : pathToString(path),\n        parent: parent,\n        parents: parents,\n        obj: obj,\n        depth: depth,\n        isCircular: isCircular,\n        circularParent: circularParent,\n        circularParentIndex: circularParentIndex,\n        isLeaf: isLeaf,\n        \"break\": function () {\n          options['break'] = true;\n          return false;\n        },\n      };\n      if (options.childrenPath !== undefined) {\n        currentObj.childrenPath =\n          options.pathFormat == 'array'\n            ? childrenPath\n            : pathToString(childrenPath);\n        context.childrenPath = currentObj.childrenPath;\n      }\n      try {\n        res = callback(value, key, parent && parent.value, context);\n      } catch (err) {\n        if (err.message) {\n          err.message += \"\\ncallback failed before deep iterate at:\\n\" + (context.path);\n        }\n        throw err;\n      }\n    }\n    if (\n      !options['break'] &&\n      res !== false &&\n      !isCircular &&\n      _.isObject(value)\n    ) {\n      if (options.childrenPath !== undefined) {\n        function forChildren(children, cp) {\n          if (children && _.isObject(children)) {\n            _.forOwn(children, function(childValue, childKey) {\n              var childPath = (path || []).concat( (cp || []), [childKey]);\n\n              iterate(\n                childValue,\n                callback,\n                options,\n                childKey,\n                childPath,\n                depth + 1,\n                currentObj,\n                currentParents,\n                obj,\n                cp\n              );\n            });\n          }\n        }\n\n        if (!depth && options.rootIsChildren) {\n          forChildren(value, undefined);\n        } else {\n          _each(options.childrenPath, function(cp) {\n            var children = _.get(value, cp);\n            forChildren(children, cp);\n          });\n        }\n      } else {\n        _.forOwn(value, function(childValue, childKey) {\n          if (_.isArray(value)) {\n            if (childValue === undefined && !(childKey in value)) {\n              return; //empty slot\n            }\n          }\n\n          var childPath = (path || []).concat( [childKey]);\n\n          iterate(\n            childValue,\n            callback,\n            options,\n            childKey,\n            childPath,\n            depth + 1,\n            currentObj,\n            currentParents,\n            obj\n          );\n        });\n      }\n    }\n    if (options.callbackAfterIterate && needCallback) {\n      context.afterIterate = true;\n      try {\n        callback(value, key, parent && parent.value, context);\n      } catch (err) {\n        if (err.message) {\n          err.message += \"\\ncallback failed after deep iterate at:\\n\" + (context.path);\n        }\n        throw err;\n      }\n    }\n  }\n  return iterate;\n}\n\nmodule.exports = getIterate;\n","'use strict';\n\nfunction getHasChildren(_) {\n  function hasChildren(obj, childrenPath) {\n    return _.some(childrenPath, function (cp) {\n      var children = _.get(obj, cp);\n      return !_.isEmpty(children);\n    });\n  }\n  return hasChildren;\n}\n\nmodule.exports = getHasChildren;\n","'use strict';\n\nvar getCondense = require('./getCondense.js');\nvar getEachDeep = require('./getEachDeep.js');\n\nfunction getCondenseDeep(_) {\n  var eachDeep = getEachDeep(_);\n  var condense = getCondense();\n  var _each = _.each || _.forArray;\n  function condenseDeep(obj, options) {\n    options = _.merge(\n      {\n        checkCircular: false,\n      },\n      options || {}\n    );\n    var eachDeepOptions = {\n      checkCircular: options.checkCircular,\n    };\n    var arrays = [];\n    //console.log('condenseDeep → eachDeep');\n    eachDeep(\n      obj,\n      function(value, key, parent, context) {\n        if (!context.isCircular && _.isArray(value)) { arrays.push(value); }\n      },\n      eachDeepOptions\n    );\n    if (_.isArray(obj)) { arrays.push(obj); }\n    _each(arrays, condense);\n    return obj;\n  }\n  return condenseDeep;\n}\n\nmodule.exports = getCondenseDeep;\n","'use strict';\n\nfunction getCondense(_) {\n  function condense(arr) {\n    var indexes = [];\n    for (var i = 0; i < arr.length; i++) {\n      if (!(i in arr)) {\n        indexes.push(i);\n      }\n    }\n    var length = indexes.length;\n\n    while (length--) {\n      arr.splice(indexes[length], 1);\n    }\n    return arr;\n  }\n  return condense;\n}\n\nmodule.exports = getCondense;\n","'use strict';\n\nfunction getExists(_) {\n  function exists(obj, path) {\n    path = _.isArray(path) ? _.clone(path) : _.toPath(path);\n    var key = path.pop();\n    var parent = path.length ? _.get(obj, path) : obj;\n    return parent !== undefined && key in parent;\n  }\n  return exists;\n}\n\ngetExists.notChainable = true;\n\nmodule.exports = getExists;\n","'use strict';\n\nfunction getObtain(_) {\n  function obtain(obj, path) {\n    if (path === undefined) {\n      return obj;\n    }\n    return _.get(obj, path);\n  }\n  return obtain;\n}\n\ngetObtain.notChainable = true;\n\nmodule.exports = getObtain;\n","'use strict';\n\nvar getEachDeep = require('./getEachDeep.js');\n\nfunction getPaths(_) {\n  var eachDeep = getEachDeep(_);\n  function paths(obj, options) {\n    if (options && options.leafsOnly !== undefined) {\n      options.leavesOnly = options.leafsOnly;\n    }\n    options = _.merge(\n      {\n        checkCircular: false,\n        includeCircularPath: true,\n        leavesOnly: !options || options.childrenPath === undefined,\n        pathFormat: 'string',\n      },\n      options || {}\n    );\n    var eachDeepOptions = {\n      pathFormat: options.pathFormat,\n      checkCircular: options.checkCircular,\n      includeRoot: options.includeRoot,\n      childrenPath: options.childrenPath,\n      rootIsChildren: options.rootIsChildren,\n      leavesOnly: options.leavesOnly,\n    };\n    var res = [];\n    eachDeep(\n      obj,\n      function(value, key, parent, context) {\n        if (!context.isCircular || options.includeCircularPath) {\n          if (context.path !== undefined) {\n            res.push(context.path);\n          }\n        }\n      },\n      eachDeepOptions\n    );\n    return res;\n  }\n  return paths;\n}\n\nmodule.exports = getPaths;\n","'use strict';\n\nvar getFilterDeep = require('./getFilterDeep.js');\nvar getPathMatches = require('./getPathMatches.js');\n\nfunction getOmitDeep(_) {\n  var pathMatches = getPathMatches(_);\n  var filterDeep = getFilterDeep(_);\n\n  function omitDeep(obj, paths, options) {\n    options = _.merge(\n      {\n        invert: false,\n      },\n      options || {}\n    );\n    var isOmit = !options.invert;\n    options = _.merge(\n      {\n        onMatch: {\n          cloneDeep: false,\n          skipChildren: false,\n          keepIfEmpty: !isOmit,\n        },\n        onNotMatch: {\n          cloneDeep: false,\n          skipChildren: false,\n          keepIfEmpty: isOmit,\n        },\n      },\n      options\n    );\n    options.leavesOnly = false;\n    options.childrenPath = undefined;\n    options.includeRoot = undefined;\n    options.pathFormat = 'array';\n    options.onTrue = options.invert ? options.onMatch : options.onNotMatch;\n    options.onFalse = options.invert ? options.onNotMatch : options.onMatch;\n\n    var test = function(value, key, parent, context) {\n      if (pathMatches(context.path, paths) !== false) {\n        return options.invert;\n      } else {\n        return !options.invert;\n      }\n    };\n    return filterDeep(obj, test, options);\n  }\n  return omitDeep;\n}\n\nmodule.exports = getOmitDeep;\n","'use strict';\n\nvar getPathToString = require('./getPathToString.js');\n\nfunction getPathMatches(_) {\n  var pathToString = getPathToString(_);\n  function pathMatches(path, paths) {\n    var pathString;\n    var pathArray;\n    if (_.isString(path)) {\n      pathString = path;\n    } else {\n      pathArray = path;\n    }\n    if (!_.isArray(paths)) {\n      paths = [paths];\n    } else {\n      paths = _.cloneDeep(paths);\n    }\n    for (var i = 0; i < paths.length; i++) {\n      if (_.isString(paths[i])) {\n        paths[i] = _.toPath(paths[i]);\n      }\n      if (_.isArray(paths[i])) {\n        if (pathArray === undefined) {\n          pathArray = _.toPath(pathString);\n        }\n        if (\n          pathArray.length >= paths[i].length &&\n          _.isEqual(_.takeRight(pathArray, paths[i].length), paths[i])\n        ) {\n          // console.log('path matched');\n          return paths[i];\n        }\n      } else if (paths[i] instanceof RegExp) {\n        if (pathString === undefined) {\n          pathString = pathToString(path);\n        }\n        if (paths[i].test(pathString)) {\n          // console.log('regex matched', paths[i]);\n          return paths[i];\n        }\n      } else {\n        throw new Error(\n          'To match path use only string/regex or array of them.'\n        );\n      }\n    }\n    // console.log('matched nothing');\n    return false;\n  }\n  return pathMatches;\n}\n\ngetPathMatches.notChainable = true;\n\nmodule.exports = getPathMatches;\n","// Generated automatically by nearley, version 2.19.1\n// http://github.com/Hardmath123/nearley\n// Bypasses TS6133. Allow declared but unused functions.\n// @ts-ignore\nfunction id(d: any[]): any { return d[0]; }\n\nconst formatQuery = ([type, query]) => ({type, query});\nconst emptyObject = () => ({});\nconst emptyArray = () => ([]);\n\n\nconst join = ([d]) => d.join('');\nconst extractPair = d => {\n  return d.length > 2\n\t? {[d[0]+d[1]]:{key: d[0], filter: d[1], value: d[2]}}\n\t: {[d[0]]: d[1]}\n}\nconst extractConditionToArray = d => {\n  if(!d.length) return [];\n  const output = [extractPair(d[2])];\n\n  for (let i in d[4]) {\n  \toutput.push(extractPair(d[4][i][2]))\n  }\n\n  return output\n}\nconst extractObject = d => {\n  let output = {...extractPair(d[2])};\n\n  for (let i in d[4]) {\n    output = {...output, ...extractPair(d[4][i][2])};\n  }\n\n  return output;\n}\nconst extractArray = d => {\n  const output = [d[2]];\n\n  for (let i in d[4]) {\n    output.push(d[4][i][2]);\n  }\n\n  return output;\n}\n\ninterface NearleyToken {  value: any;\n  [key: string]: any;\n};\n\ninterface NearleyLexer {\n  reset: (chunk: string, info: any) => void;\n  next: () => NearleyToken | undefined;\n  save: () => any;\n  formatError: (token: NearleyToken) => string;\n  has: (tokenType: string) => boolean;\n};\n\ninterface NearleyRule {\n  name: string;\n  symbols: NearleySymbol[];\n  postprocess?: (d: any[], loc?: number, reject?: {}) => any;\n};\n\ntype NearleySymbol = string | { literal: any } | { test: (token: any) => boolean };\n\ninterface Grammar {\n  Lexer: NearleyLexer | undefined;\n  ParserRules: NearleyRule[];\n  ParserStart: string;\n};\n\nconst grammar: Grammar = {\n  Lexer: undefined,\n  ParserRules: [\n    {\"name\": \"unsigned_int$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"unsigned_int$ebnf$1\", \"symbols\": [\"unsigned_int$ebnf$1\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"unsigned_int\", \"symbols\": [\"unsigned_int$ebnf$1\"], \"postprocess\": \n        function(d) {\n            return parseInt(d[0].join(\"\"));\n        }\n        },\n    {\"name\": \"int$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"-\"}]},\n    {\"name\": \"int$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"+\"}]},\n    {\"name\": \"int$ebnf$1\", \"symbols\": [\"int$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"int$ebnf$1\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"int$ebnf$2\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"int$ebnf$2\", \"symbols\": [\"int$ebnf$2\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"int\", \"symbols\": [\"int$ebnf$1\", \"int$ebnf$2\"], \"postprocess\": \n        function(d) {\n            if (d[0]) {\n                return parseInt(d[0][0]+d[1].join(\"\"));\n            } else {\n                return parseInt(d[1].join(\"\"));\n            }\n        }\n        },\n    {\"name\": \"unsigned_decimal$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"unsigned_decimal$ebnf$1\", \"symbols\": [\"unsigned_decimal$ebnf$1\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [\"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"unsigned_decimal$ebnf$2$subexpression$1\", \"symbols\": [{\"literal\":\".\"}, \"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1\"]},\n    {\"name\": \"unsigned_decimal$ebnf$2\", \"symbols\": [\"unsigned_decimal$ebnf$2$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"unsigned_decimal$ebnf$2\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"unsigned_decimal\", \"symbols\": [\"unsigned_decimal$ebnf$1\", \"unsigned_decimal$ebnf$2\"], \"postprocess\": \n        function(d) {\n            return parseFloat(\n                d[0].join(\"\") +\n                (d[1] ? \".\"+d[1][1].join(\"\") : \"\")\n            );\n        }\n        },\n    {\"name\": \"decimal$ebnf$1\", \"symbols\": [{\"literal\":\"-\"}], \"postprocess\": id},\n    {\"name\": \"decimal$ebnf$1\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"decimal$ebnf$2\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"decimal$ebnf$2\", \"symbols\": [\"decimal$ebnf$2\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"decimal$ebnf$3$subexpression$1$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"decimal$ebnf$3$subexpression$1$ebnf$1\", \"symbols\": [\"decimal$ebnf$3$subexpression$1$ebnf$1\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"decimal$ebnf$3$subexpression$1\", \"symbols\": [{\"literal\":\".\"}, \"decimal$ebnf$3$subexpression$1$ebnf$1\"]},\n    {\"name\": \"decimal$ebnf$3\", \"symbols\": [\"decimal$ebnf$3$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"decimal$ebnf$3\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"decimal\", \"symbols\": [\"decimal$ebnf$1\", \"decimal$ebnf$2\", \"decimal$ebnf$3\"], \"postprocess\": \n        function(d) {\n            return parseFloat(\n                (d[0] || \"\") +\n                d[1].join(\"\") +\n                (d[2] ? \".\"+d[2][1].join(\"\") : \"\")\n            );\n        }\n        },\n    {\"name\": \"percentage\", \"symbols\": [\"decimal\", {\"literal\":\"%\"}], \"postprocess\": \n        function(d) {\n            return d[0]/100;\n        }\n        },\n    {\"name\": \"jsonfloat$ebnf$1\", \"symbols\": [{\"literal\":\"-\"}], \"postprocess\": id},\n    {\"name\": \"jsonfloat$ebnf$1\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"jsonfloat$ebnf$2\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"jsonfloat$ebnf$2\", \"symbols\": [\"jsonfloat$ebnf$2\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"jsonfloat$ebnf$3$subexpression$1$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"jsonfloat$ebnf$3$subexpression$1$ebnf$1\", \"symbols\": [\"jsonfloat$ebnf$3$subexpression$1$ebnf$1\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"jsonfloat$ebnf$3$subexpression$1\", \"symbols\": [{\"literal\":\".\"}, \"jsonfloat$ebnf$3$subexpression$1$ebnf$1\"]},\n    {\"name\": \"jsonfloat$ebnf$3\", \"symbols\": [\"jsonfloat$ebnf$3$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"jsonfloat$ebnf$3\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"jsonfloat$ebnf$4$subexpression$1$ebnf$1\", \"symbols\": [/[+-]/], \"postprocess\": id},\n    {\"name\": \"jsonfloat$ebnf$4$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"jsonfloat$ebnf$4$subexpression$1$ebnf$2\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"jsonfloat$ebnf$4$subexpression$1$ebnf$2\", \"symbols\": [\"jsonfloat$ebnf$4$subexpression$1$ebnf$2\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"jsonfloat$ebnf$4$subexpression$1\", \"symbols\": [/[eE]/, \"jsonfloat$ebnf$4$subexpression$1$ebnf$1\", \"jsonfloat$ebnf$4$subexpression$1$ebnf$2\"]},\n    {\"name\": \"jsonfloat$ebnf$4\", \"symbols\": [\"jsonfloat$ebnf$4$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"jsonfloat$ebnf$4\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"jsonfloat\", \"symbols\": [\"jsonfloat$ebnf$1\", \"jsonfloat$ebnf$2\", \"jsonfloat$ebnf$3\", \"jsonfloat$ebnf$4\"], \"postprocess\": \n        function(d) {\n            return parseFloat(\n                (d[0] || \"\") +\n                d[1].join(\"\") +\n                (d[2] ? \".\"+d[2][1].join(\"\") : \"\") +\n                (d[3] ? \"e\" + (d[3][1] || \"+\") + d[3][2].join(\"\") : \"\")\n            );\n        }\n        },\n    {\"name\": \"regexp$string$1\", \"symbols\": [{\"literal\":\"=\"}, {\"literal\":\"~\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"regexp\", \"symbols\": [\"regexp$string$1\"], \"postprocess\": id},\n    {\"name\": \"regexp$string$2\", \"symbols\": [{\"literal\":\"!\"}, {\"literal\":\"~\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"regexp\", \"symbols\": [\"regexp$string$2\"], \"postprocess\": id},\n    {\"name\": \"equals\", \"symbols\": [{\"literal\":\"=\"}], \"postprocess\": id},\n    {\"name\": \"not_equals$string$1\", \"symbols\": [{\"literal\":\"!\"}, {\"literal\":\"=\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"not_equals\", \"symbols\": [\"not_equals$string$1\"], \"postprocess\": id},\n    {\"name\": \"prop_name$ebnf$1\", \"symbols\": [/[A-Za-z0-9_]/]},\n    {\"name\": \"prop_name$ebnf$1\", \"symbols\": [\"prop_name$ebnf$1\", /[A-Za-z0-9_]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"prop_name\", \"symbols\": [\"prop_name$ebnf$1\"], \"postprocess\": join},\n    {\"name\": \"number\", \"symbols\": [\"decimal\"], \"postprocess\": id},\n    {\"name\": \"dqstring$ebnf$1\", \"symbols\": []},\n    {\"name\": \"dqstring$ebnf$1\", \"symbols\": [\"dqstring$ebnf$1\", \"dstrchar\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"dqstring\", \"symbols\": [{\"literal\":\"\\\"\"}, \"dqstring$ebnf$1\", {\"literal\":\"\\\"\"}], \"postprocess\": d => d[1].join(\"\")},\n    {\"name\": \"sqstring$ebnf$1\", \"symbols\": []},\n    {\"name\": \"sqstring$ebnf$1\", \"symbols\": [\"sqstring$ebnf$1\", \"sstrchar\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"sqstring\", \"symbols\": [{\"literal\":\"'\"}, \"sqstring$ebnf$1\", {\"literal\":\"'\"}], \"postprocess\": d => d[1].join(\"\")},\n    {\"name\": \"dqregexp$ebnf$1\", \"symbols\": []},\n    {\"name\": \"dqregexp$ebnf$1\", \"symbols\": [\"dqregexp$ebnf$1\", \"ndstrchar\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"dqregexp\", \"symbols\": [{\"literal\":\"\\\"\"}, \"dqregexp$ebnf$1\", {\"literal\":\"\\\"\"}], \"postprocess\": d => d[1].join(\"\")},\n    {\"name\": \"sqregexp$ebnf$1\", \"symbols\": []},\n    {\"name\": \"sqregexp$ebnf$1\", \"symbols\": [\"sqregexp$ebnf$1\", \"nsstrchar\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"sqregexp\", \"symbols\": [{\"literal\":\"'\"}, \"sqregexp$ebnf$1\", {\"literal\":\"'\"}], \"postprocess\": d => d[1].join(\"\")},\n    {\"name\": \"dstrchar\", \"symbols\": [/[^\\\\\"\\n]/], \"postprocess\": id},\n    {\"name\": \"dstrchar\", \"symbols\": [\"backslash\", \"strescape\"], \"postprocess\": d => JSON.parse(\"\\\"\"+d.join(\"\")+\"\\\"\")},\n    {\"name\": \"dstrchar$string$1\", \"symbols\": [{\"literal\":\"\\\\\"}, {\"literal\":\"\\\"\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"dstrchar\", \"symbols\": [\"dstrchar$string$1\"], \"postprocess\": d => \"\\\"\"},\n    {\"name\": \"sstrchar\", \"symbols\": [/[^\\\\'\\n]/], \"postprocess\": id},\n    {\"name\": \"sstrchar\", \"symbols\": [\"backslash\", \"strescape\"], \"postprocess\": d => JSON.parse(\"\\\"\"+d.join(\"\")+\"\\\"\")},\n    {\"name\": \"sstrchar$string$1\", \"symbols\": [{\"literal\":\"\\\\\"}, {\"literal\":\"'\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"sstrchar\", \"symbols\": [\"sstrchar$string$1\"], \"postprocess\": d => \"'\"},\n    {\"name\": \"ndstrchar\", \"symbols\": [/[^\\\\\"\\n]/], \"postprocess\": id},\n    {\"name\": \"ndstrchar\", \"symbols\": [\"backslash\", \"unicode\"], \"postprocess\": d => JSON.parse(\"\\\"\"+d.join(\"\")+\"\\\"\")},\n    {\"name\": \"ndstrchar$string$1\", \"symbols\": [{\"literal\":\"\\\\\"}, {\"literal\":\"\\\"\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"ndstrchar\", \"symbols\": [\"ndstrchar$string$1\"], \"postprocess\": d => \"\\\\\\\"\"},\n    {\"name\": \"ndstrchar\", \"symbols\": [\"backslash\"], \"postprocess\": id},\n    {\"name\": \"nsstrchar\", \"symbols\": [/[^\\\\'\\n]/], \"postprocess\": id},\n    {\"name\": \"nsstrchar\", \"symbols\": [\"backslash\", \"unicode\"], \"postprocess\": d => JSON.parse(\"\\\"\"+d.join(\"\")+\"\\\"\")},\n    {\"name\": \"nsstrchar$string$1\", \"symbols\": [{\"literal\":\"\\\\\"}, {\"literal\":\"'\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"nsstrchar\", \"symbols\": [\"nsstrchar$string$1\"], \"postprocess\": d => \"\\\\'\"},\n    {\"name\": \"nsstrchar\", \"symbols\": [\"backslash\"], \"postprocess\": id},\n    {\"name\": \"strescape\", \"symbols\": [/[\"\\\\/bfnrt]/], \"postprocess\": id},\n    {\"name\": \"strescape\", \"symbols\": [\"unicode\"], \"postprocess\": id},\n    {\"name\": \"backslash\", \"symbols\": [{\"literal\":\"\\\\\"}], \"postprocess\": d => \"\\\\\"},\n    {\"name\": \"unicode\", \"symbols\": [{\"literal\":\"u\"}, /[a-fA-F0-9]/, /[a-fA-F0-9]/, /[a-fA-F0-9]/, /[a-fA-F0-9]/], \"postprocess\": d => d.join(\"\")},\n    {\"name\": \"_$ebnf$1\", \"symbols\": []},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", /[\\s]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"], \"postprocess\": null},\n    {\"name\": \"value\", \"symbols\": [\"object\"], \"postprocess\": id},\n    {\"name\": \"value\", \"symbols\": [\"array\"], \"postprocess\": id},\n    {\"name\": \"value\", \"symbols\": [\"primitive\"], \"postprocess\": id},\n    {\"name\": \"primitive\", \"symbols\": [\"number\"], \"postprocess\": id},\n    {\"name\": \"primitive\", \"symbols\": [\"string\"], \"postprocess\": id},\n    {\"name\": \"primitive$string$1\", \"symbols\": [{\"literal\":\"t\"}, {\"literal\":\"r\"}, {\"literal\":\"u\"}, {\"literal\":\"e\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"primitive\", \"symbols\": [\"primitive$string$1\"], \"postprocess\": () => true},\n    {\"name\": \"primitive$string$2\", \"symbols\": [{\"literal\":\"f\"}, {\"literal\":\"a\"}, {\"literal\":\"l\"}, {\"literal\":\"s\"}, {\"literal\":\"e\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"primitive\", \"symbols\": [\"primitive$string$2\"], \"postprocess\": () => false},\n    {\"name\": \"primitive$string$3\", \"symbols\": [{\"literal\":\"n\"}, {\"literal\":\"u\"}, {\"literal\":\"l\"}, {\"literal\":\"l\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"primitive\", \"symbols\": [\"primitive$string$3\"], \"postprocess\": () => null},\n    {\"name\": \"rule\", \"symbols\": [\"type\", \"condition\"], \"postprocess\": formatQuery},\n    {\"name\": \"type$string$1\", \"symbols\": [{\"literal\":\"a\"}, {\"literal\":\"s\"}, {\"literal\":\"s\"}, {\"literal\":\"e\"}, {\"literal\":\"t\"}, {\"literal\":\"s\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"type\", \"symbols\": [\"type$string$1\"], \"postprocess\": id},\n    {\"name\": \"type$string$2\", \"symbols\": [{\"literal\":\"e\"}, {\"literal\":\"v\"}, {\"literal\":\"e\"}, {\"literal\":\"n\"}, {\"literal\":\"t\"}, {\"literal\":\"s\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"type\", \"symbols\": [\"type$string$2\"], \"postprocess\": id},\n    {\"name\": \"condition\", \"symbols\": [{\"literal\":\"{\"}, {\"literal\":\"}\"}], \"postprocess\": emptyArray},\n    {\"name\": \"condition$ebnf$1\", \"symbols\": []},\n    {\"name\": \"condition$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\",\"}, \"_\", \"pair\", \"_\"]},\n    {\"name\": \"condition$ebnf$1\", \"symbols\": [\"condition$ebnf$1\", \"condition$ebnf$1$subexpression$1\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"condition\", \"symbols\": [{\"literal\":\"{\"}, \"_\", \"pair\", \"_\", \"condition$ebnf$1\", \"_\", {\"literal\":\"}\"}], \"postprocess\": extractConditionToArray},\n    {\"name\": \"regexp_string\", \"symbols\": [\"sqregexp\"], \"postprocess\": id},\n    {\"name\": \"regexp_string\", \"symbols\": [\"dqregexp\"], \"postprocess\": id},\n    {\"name\": \"string\", \"symbols\": [\"sqstring\"], \"postprocess\": id},\n    {\"name\": \"string\", \"symbols\": [\"dqstring\"], \"postprocess\": id},\n    {\"name\": \"array\", \"symbols\": [{\"literal\":\"[\"}, \"_\", {\"literal\":\"]\"}], \"postprocess\": emptyArray},\n    {\"name\": \"array$ebnf$1\", \"symbols\": []},\n    {\"name\": \"array$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\",\"}, \"_\", \"value\", \"_\"]},\n    {\"name\": \"array$ebnf$1\", \"symbols\": [\"array$ebnf$1\", \"array$ebnf$1$subexpression$1\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"array\", \"symbols\": [{\"literal\":\"[\"}, \"_\", \"value\", \"_\", \"array$ebnf$1\", \"_\", {\"literal\":\"]\"}], \"postprocess\": extractArray},\n    {\"name\": \"object\", \"symbols\": [{\"literal\":\"{\"}, \"_\", {\"literal\":\"}\"}], \"postprocess\": emptyObject},\n    {\"name\": \"object$ebnf$1\", \"symbols\": []},\n    {\"name\": \"object$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\",\"}, \"_\", \"pair\", \"_\"]},\n    {\"name\": \"object$ebnf$1\", \"symbols\": [\"object$ebnf$1\", \"object$ebnf$1$subexpression$1\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"object\", \"symbols\": [{\"literal\":\"{\"}, \"_\", \"pair\", \"_\", \"object$ebnf$1\", \"_\", {\"literal\":\"}\"}], \"postprocess\": extractObject},\n    {\"name\": \"pair\", \"symbols\": [\"prop_name\", \"_\", \"equals\", \"_\", \"value\"], \"postprocess\": d => [d[0], d[4]]},\n    {\"name\": \"pair\", \"symbols\": [\"prop_name\", \"_\", \"regexp\", \"_\", \"regexp_string\"], \"postprocess\": d => [d[0], d[2], d[4]]},\n    {\"name\": \"pair\", \"symbols\": [\"prop_name\", \"_\", \"not_equals\", \"_\", \"primitive\"], \"postprocess\": d => [d[0], d[2], d[4]]}\n  ],\n  ParserStart: \"rule\",\n};\n\nexport default grammar;\n","// Generated automatically by nearley, version 2.19.1\n// http://github.com/Hardmath123/nearley\n// Bypasses TS6133. Allow declared but unused functions.\n// @ts-ignore\nfunction id(d: any[]): any { return d[0]; }\n\nconst formatQuery = ([type, query]) => ({type, query});\nconst emptyObject = () => ({});\nconst emptyArray = () => ([]);\n\n\nconst join = ([d]) => joinArr(d);\nconst joinArr = (d) => d.join('');\nconst extractPair = d => {\n  return {\n\t  path: d[0],\n\t  filter: d[1],\n\t  value: d[2]\n  }\n}\nconst extractConditionPair = ([path, filter, value]) => {\n  return path ? {path, filter, value} : {}\n}\n\nconst extract = (extractor, d) => {\n  let output = {...extractor(d[1])};\n\n  for (let i in d[2]) {\n    output = {...output, ...extractor(d[2][i][2])};\n  }\n\n  return output;\n}\nconst extractConditionToArray = d => {\n  if(!d.length) return [];\n  const output = [extractPair(d[1])];\n\n  for (let i in d[2]) {\n    output.push(extractPair(d[2][i][1]))\n  }\n\n  return output\n}\nconst extractObject = d => {\n  let output = [extractPair(d[1])];\n\n  for (let i in d[2]) {\n    output.push(extractPair(d[2][i][1]));\n  }\n\n  return output;\n}\nconst extractArray = d => {\n  const output = [d[1]];\n\n  for (let i in d[2]) {\n    output.push(d[2][i][1]);\n  }\n\n  return output;\n}\nconst extractOperationsArray = d => {\n  const output = Array.isArray(d[0]) ? [...d[0]] : [d[0]];\n\n  for (let i in d[1]) {\n    const flatten = [].concat(...d[1][i])\n    output.push(...flatten);\n  }\n\n  return output;\n}\nconst extractCommaSeparatedArray = d => {\n  const output = [d[0]];\n\n  for (let i in d[1]) {\n    output.push(d[1][i][1]);\n  }\n  return output;\n}\nconst extractMapFuncArgs = d => {\n  return d.filter(d => d !== ',')\n}\nconst extract2Elements = d => {\n\treturn [d[0], d[2]]\n}\nconst extractOperator = ([s, operator, S]) => {\n  return { operator }\n}\nconst extractNumber = ([constant]) => {\n  return { constant }\n}\nconst extractPI = d => {\n  return { constant: d[0] + d[2] }\n}\nconst extractFunction = ([func, br, args, BR]) => {\n  if (args && args.length) {\n    return { func: func || '', args }\n  }\n  return { func }\n}\nconst extractUnaryOperator = ([operator, element]) => operator ? [operator[0], element] : element;\n\ninterface NearleyToken {  value: any;\n  [key: string]: any;\n};\n\ninterface NearleyLexer {\n  reset: (chunk: string, info: any) => void;\n  next: () => NearleyToken | undefined;\n  save: () => any;\n  formatError: (token: NearleyToken) => string;\n  has: (tokenType: string) => boolean;\n};\n\ninterface NearleyRule {\n  name: string;\n  symbols: NearleySymbol[];\n  postprocess?: (d: any[], loc?: number, reject?: {}) => any;\n};\n\ntype NearleySymbol = string | { literal: any } | { test: (token: any) => boolean };\n\ninterface Grammar {\n  Lexer: NearleyLexer | undefined;\n  ParserRules: NearleyRule[];\n  ParserStart: string;\n};\n\nconst grammar: Grammar = {\n  Lexer: undefined,\n  ParserRules: [\n    {\"name\": \"unsigned_int$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"unsigned_int$ebnf$1\", \"symbols\": [\"unsigned_int$ebnf$1\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"unsigned_int\", \"symbols\": [\"unsigned_int$ebnf$1\"], \"postprocess\": \n        function(d) {\n            return parseInt(d[0].join(\"\"));\n        }\n        },\n    {\"name\": \"int$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"-\"}]},\n    {\"name\": \"int$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"+\"}]},\n    {\"name\": \"int$ebnf$1\", \"symbols\": [\"int$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"int$ebnf$1\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"int$ebnf$2\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"int$ebnf$2\", \"symbols\": [\"int$ebnf$2\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"int\", \"symbols\": [\"int$ebnf$1\", \"int$ebnf$2\"], \"postprocess\": \n        function(d) {\n            if (d[0]) {\n                return parseInt(d[0][0]+d[1].join(\"\"));\n            } else {\n                return parseInt(d[1].join(\"\"));\n            }\n        }\n        },\n    {\"name\": \"unsigned_decimal$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"unsigned_decimal$ebnf$1\", \"symbols\": [\"unsigned_decimal$ebnf$1\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [\"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"unsigned_decimal$ebnf$2$subexpression$1\", \"symbols\": [{\"literal\":\".\"}, \"unsigned_decimal$ebnf$2$subexpression$1$ebnf$1\"]},\n    {\"name\": \"unsigned_decimal$ebnf$2\", \"symbols\": [\"unsigned_decimal$ebnf$2$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"unsigned_decimal$ebnf$2\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"unsigned_decimal\", \"symbols\": [\"unsigned_decimal$ebnf$1\", \"unsigned_decimal$ebnf$2\"], \"postprocess\": \n        function(d) {\n            return parseFloat(\n                d[0].join(\"\") +\n                (d[1] ? \".\"+d[1][1].join(\"\") : \"\")\n            );\n        }\n        },\n    {\"name\": \"decimal$ebnf$1\", \"symbols\": [{\"literal\":\"-\"}], \"postprocess\": id},\n    {\"name\": \"decimal$ebnf$1\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"decimal$ebnf$2\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"decimal$ebnf$2\", \"symbols\": [\"decimal$ebnf$2\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"decimal$ebnf$3$subexpression$1$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"decimal$ebnf$3$subexpression$1$ebnf$1\", \"symbols\": [\"decimal$ebnf$3$subexpression$1$ebnf$1\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"decimal$ebnf$3$subexpression$1\", \"symbols\": [{\"literal\":\".\"}, \"decimal$ebnf$3$subexpression$1$ebnf$1\"]},\n    {\"name\": \"decimal$ebnf$3\", \"symbols\": [\"decimal$ebnf$3$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"decimal$ebnf$3\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"decimal\", \"symbols\": [\"decimal$ebnf$1\", \"decimal$ebnf$2\", \"decimal$ebnf$3\"], \"postprocess\": \n        function(d) {\n            return parseFloat(\n                (d[0] || \"\") +\n                d[1].join(\"\") +\n                (d[2] ? \".\"+d[2][1].join(\"\") : \"\")\n            );\n        }\n        },\n    {\"name\": \"percentage\", \"symbols\": [\"decimal\", {\"literal\":\"%\"}], \"postprocess\": \n        function(d) {\n            return d[0]/100;\n        }\n        },\n    {\"name\": \"jsonfloat$ebnf$1\", \"symbols\": [{\"literal\":\"-\"}], \"postprocess\": id},\n    {\"name\": \"jsonfloat$ebnf$1\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"jsonfloat$ebnf$2\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"jsonfloat$ebnf$2\", \"symbols\": [\"jsonfloat$ebnf$2\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"jsonfloat$ebnf$3$subexpression$1$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"jsonfloat$ebnf$3$subexpression$1$ebnf$1\", \"symbols\": [\"jsonfloat$ebnf$3$subexpression$1$ebnf$1\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"jsonfloat$ebnf$3$subexpression$1\", \"symbols\": [{\"literal\":\".\"}, \"jsonfloat$ebnf$3$subexpression$1$ebnf$1\"]},\n    {\"name\": \"jsonfloat$ebnf$3\", \"symbols\": [\"jsonfloat$ebnf$3$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"jsonfloat$ebnf$3\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"jsonfloat$ebnf$4$subexpression$1$ebnf$1\", \"symbols\": [/[+-]/], \"postprocess\": id},\n    {\"name\": \"jsonfloat$ebnf$4$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"jsonfloat$ebnf$4$subexpression$1$ebnf$2\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"jsonfloat$ebnf$4$subexpression$1$ebnf$2\", \"symbols\": [\"jsonfloat$ebnf$4$subexpression$1$ebnf$2\", /[0-9]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"jsonfloat$ebnf$4$subexpression$1\", \"symbols\": [/[eE]/, \"jsonfloat$ebnf$4$subexpression$1$ebnf$1\", \"jsonfloat$ebnf$4$subexpression$1$ebnf$2\"]},\n    {\"name\": \"jsonfloat$ebnf$4\", \"symbols\": [\"jsonfloat$ebnf$4$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"jsonfloat$ebnf$4\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"jsonfloat\", \"symbols\": [\"jsonfloat$ebnf$1\", \"jsonfloat$ebnf$2\", \"jsonfloat$ebnf$3\", \"jsonfloat$ebnf$4\"], \"postprocess\": \n        function(d) {\n            return parseFloat(\n                (d[0] || \"\") +\n                d[1].join(\"\") +\n                (d[2] ? \".\"+d[2][1].join(\"\") : \"\") +\n                (d[3] ? \"e\" + (d[3][1] || \"+\") + d[3][2].join(\"\") : \"\")\n            );\n        }\n        },\n    {\"name\": \"regexp$string$1\", \"symbols\": [{\"literal\":\"=\"}, {\"literal\":\"~\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"regexp\", \"symbols\": [\"regexp$string$1\"], \"postprocess\": id},\n    {\"name\": \"regexp$string$2\", \"symbols\": [{\"literal\":\"!\"}, {\"literal\":\"~\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"regexp\", \"symbols\": [\"regexp$string$2\"], \"postprocess\": id},\n    {\"name\": \"equals\", \"symbols\": [{\"literal\":\"=\"}], \"postprocess\": id},\n    {\"name\": \"not_equals$string$1\", \"symbols\": [{\"literal\":\"!\"}, {\"literal\":\"=\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"not_equals\", \"symbols\": [\"not_equals$string$1\"], \"postprocess\": id},\n    {\"name\": \"prop_name$ebnf$1\", \"symbols\": [/[A-Za-z0-9_]/]},\n    {\"name\": \"prop_name$ebnf$1\", \"symbols\": [\"prop_name$ebnf$1\", /[A-Za-z0-9_]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"prop_name\", \"symbols\": [\"prop_name$ebnf$1\"], \"postprocess\": join},\n    {\"name\": \"number\", \"symbols\": [\"decimal\"], \"postprocess\": id},\n    {\"name\": \"dqstring$ebnf$1\", \"symbols\": []},\n    {\"name\": \"dqstring$ebnf$1\", \"symbols\": [\"dqstring$ebnf$1\", \"dstrchar\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"dqstring\", \"symbols\": [{\"literal\":\"\\\"\"}, \"dqstring$ebnf$1\", {\"literal\":\"\\\"\"}], \"postprocess\": d => d[1].join(\"\")},\n    {\"name\": \"sqstring$ebnf$1\", \"symbols\": []},\n    {\"name\": \"sqstring$ebnf$1\", \"symbols\": [\"sqstring$ebnf$1\", \"sstrchar\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"sqstring\", \"symbols\": [{\"literal\":\"'\"}, \"sqstring$ebnf$1\", {\"literal\":\"'\"}], \"postprocess\": d => d[1].join(\"\")},\n    {\"name\": \"dqregexp$ebnf$1\", \"symbols\": []},\n    {\"name\": \"dqregexp$ebnf$1\", \"symbols\": [\"dqregexp$ebnf$1\", \"ndstrchar\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"dqregexp\", \"symbols\": [{\"literal\":\"\\\"\"}, \"dqregexp$ebnf$1\", {\"literal\":\"\\\"\"}], \"postprocess\": d => d[1].join(\"\")},\n    {\"name\": \"sqregexp$ebnf$1\", \"symbols\": []},\n    {\"name\": \"sqregexp$ebnf$1\", \"symbols\": [\"sqregexp$ebnf$1\", \"nsstrchar\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"sqregexp\", \"symbols\": [{\"literal\":\"'\"}, \"sqregexp$ebnf$1\", {\"literal\":\"'\"}], \"postprocess\": d => d[1].join(\"\")},\n    {\"name\": \"dstrchar\", \"symbols\": [/[^\\\\\"\\n]/], \"postprocess\": id},\n    {\"name\": \"dstrchar\", \"symbols\": [\"backslash\", \"strescape\"], \"postprocess\": d => JSON.parse(\"\\\"\"+d.join(\"\")+\"\\\"\")},\n    {\"name\": \"dstrchar$string$1\", \"symbols\": [{\"literal\":\"\\\\\"}, {\"literal\":\"\\\"\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"dstrchar\", \"symbols\": [\"dstrchar$string$1\"], \"postprocess\": d => \"\\\"\"},\n    {\"name\": \"sstrchar\", \"symbols\": [/[^\\\\'\\n]/], \"postprocess\": id},\n    {\"name\": \"sstrchar\", \"symbols\": [\"backslash\", \"strescape\"], \"postprocess\": d => JSON.parse(\"\\\"\"+d.join(\"\")+\"\\\"\")},\n    {\"name\": \"sstrchar$string$1\", \"symbols\": [{\"literal\":\"\\\\\"}, {\"literal\":\"'\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"sstrchar\", \"symbols\": [\"sstrchar$string$1\"], \"postprocess\": d => \"'\"},\n    {\"name\": \"ndstrchar\", \"symbols\": [/[^\\\\\"\\n]/], \"postprocess\": id},\n    {\"name\": \"ndstrchar\", \"symbols\": [\"backslash\", \"unicode\"], \"postprocess\": d => JSON.parse(\"\\\"\"+d.join(\"\")+\"\\\"\")},\n    {\"name\": \"ndstrchar$string$1\", \"symbols\": [{\"literal\":\"\\\\\"}, {\"literal\":\"\\\"\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"ndstrchar\", \"symbols\": [\"ndstrchar$string$1\"], \"postprocess\": d => \"\\\\\\\"\"},\n    {\"name\": \"ndstrchar\", \"symbols\": [\"backslash\"], \"postprocess\": id},\n    {\"name\": \"nsstrchar\", \"symbols\": [/[^\\\\'\\n]/], \"postprocess\": id},\n    {\"name\": \"nsstrchar\", \"symbols\": [\"backslash\", \"unicode\"], \"postprocess\": d => JSON.parse(\"\\\"\"+d.join(\"\")+\"\\\"\")},\n    {\"name\": \"nsstrchar$string$1\", \"symbols\": [{\"literal\":\"\\\\\"}, {\"literal\":\"'\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"nsstrchar\", \"symbols\": [\"nsstrchar$string$1\"], \"postprocess\": d => \"\\\\'\"},\n    {\"name\": \"nsstrchar\", \"symbols\": [\"backslash\"], \"postprocess\": id},\n    {\"name\": \"strescape\", \"symbols\": [/[\"\\\\/bfnrt]/], \"postprocess\": id},\n    {\"name\": \"strescape\", \"symbols\": [\"unicode\"], \"postprocess\": id},\n    {\"name\": \"backslash\", \"symbols\": [{\"literal\":\"\\\\\"}], \"postprocess\": d => \"\\\\\"},\n    {\"name\": \"unicode\", \"symbols\": [{\"literal\":\"u\"}, /[a-fA-F0-9]/, /[a-fA-F0-9]/, /[a-fA-F0-9]/, /[a-fA-F0-9]/], \"postprocess\": d => d.join(\"\")},\n    {\"name\": \"_$ebnf$1\", \"symbols\": []},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", /[\\s]/], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"], \"postprocess\": null},\n    {\"name\": \"value\", \"symbols\": [\"object\"], \"postprocess\": id},\n    {\"name\": \"value\", \"symbols\": [\"array\"], \"postprocess\": id},\n    {\"name\": \"value\", \"symbols\": [\"primitive\"], \"postprocess\": id},\n    {\"name\": \"primitive\", \"symbols\": [\"number\"], \"postprocess\": id},\n    {\"name\": \"primitive\", \"symbols\": [\"string\"], \"postprocess\": id},\n    {\"name\": \"primitive$string$1\", \"symbols\": [{\"literal\":\"t\"}, {\"literal\":\"r\"}, {\"literal\":\"u\"}, {\"literal\":\"e\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"primitive\", \"symbols\": [\"primitive$string$1\"], \"postprocess\": () => true},\n    {\"name\": \"primitive$string$2\", \"symbols\": [{\"literal\":\"f\"}, {\"literal\":\"a\"}, {\"literal\":\"l\"}, {\"literal\":\"s\"}, {\"literal\":\"e\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"primitive\", \"symbols\": [\"primitive$string$2\"], \"postprocess\": () => false},\n    {\"name\": \"primitive$string$3\", \"symbols\": [{\"literal\":\"n\"}, {\"literal\":\"u\"}, {\"literal\":\"l\"}, {\"literal\":\"l\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"primitive\", \"symbols\": [\"primitive$string$3\"], \"postprocess\": () => null},\n    {\"name\": \"query\", \"symbols\": [\"_\", \"trimmed\", \"_\"], \"postprocess\": d => d[1]},\n    {\"name\": \"trimmed\", \"symbols\": [\"compositeElement\"], \"postprocess\": id},\n    {\"name\": \"trimmed\", \"symbols\": [\"function\"], \"postprocess\": id},\n    {\"name\": \"function\", \"symbols\": [\"unary\", \"br\", \"arithmeticElements\", \"BR\"], \"postprocess\": extractFunction},\n    {\"name\": \"function\", \"symbols\": [\"unary\", \"br\", \"oneElement\", \"BR\"], \"postprocess\": extractFunction},\n    {\"name\": \"function\", \"symbols\": [\"binary\", \"br\", \"twoElements\", \"BR\"], \"postprocess\": extractFunction},\n    {\"name\": \"function\", \"symbols\": [\"n_ary\", \"br\", \"commaSeparatedElements\", \"BR\"], \"postprocess\": extractFunction},\n    {\"name\": \"function$string$1\", \"symbols\": [{\"literal\":\"m\"}, {\"literal\":\"a\"}, {\"literal\":\"p\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"function\", \"symbols\": [\"function$string$1\", \"br\", \"map_func_args\", \"BR\"], \"postprocess\": extractFunction},\n    {\"name\": \"oneElement\", \"symbols\": [\"arithmeticElement\"], \"postprocess\": ([d]) => Array.isArray(d) ? d : [d]},\n    {\"name\": \"twoElements\", \"symbols\": [\"compositeElement\", \"comma\", \"compositeElement\"], \"postprocess\": extract2Elements},\n    {\"name\": \"commaSeparatedElements$ebnf$1\", \"symbols\": []},\n    {\"name\": \"commaSeparatedElements$ebnf$1$subexpression$1\", \"symbols\": [\"comma\", \"compositeElement\"]},\n    {\"name\": \"commaSeparatedElements$ebnf$1\", \"symbols\": [\"commaSeparatedElements$ebnf$1\", \"commaSeparatedElements$ebnf$1$subexpression$1\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"commaSeparatedElements\", \"symbols\": [\"compositeElement\", \"commaSeparatedElements$ebnf$1\"], \"postprocess\": extractCommaSeparatedArray},\n    {\"name\": \"arithmeticElements$ebnf$1$subexpression$1\", \"symbols\": [\"operator\", \"arithmeticElement\"]},\n    {\"name\": \"arithmeticElements$ebnf$1\", \"symbols\": [\"arithmeticElements$ebnf$1$subexpression$1\"]},\n    {\"name\": \"arithmeticElements$ebnf$1$subexpression$2\", \"symbols\": [\"operator\", \"arithmeticElement\"]},\n    {\"name\": \"arithmeticElements$ebnf$1\", \"symbols\": [\"arithmeticElements$ebnf$1\", \"arithmeticElements$ebnf$1$subexpression$2\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"arithmeticElements\", \"symbols\": [\"arithmeticElement\", \"arithmeticElements$ebnf$1\"], \"postprocess\": extractOperationsArray},\n    {\"name\": \"map_func_args\", \"symbols\": [\"compositeElement\", {\"literal\":\",\"}, \"array\", {\"literal\":\",\"}, \"array\", \"comma\", \"number\"], \"postprocess\": extractMapFuncArgs},\n    {\"name\": \"compositeElement\", \"symbols\": [\"arithmeticElement\"], \"postprocess\": id},\n    {\"name\": \"compositeElement\", \"symbols\": [\"arithmeticElements\"], \"postprocess\": id},\n    {\"name\": \"arithmeticElement$ebnf$1$subexpression$1\", \"symbols\": [\"unary_operator\"]},\n    {\"name\": \"arithmeticElement$ebnf$1\", \"symbols\": [\"arithmeticElement$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"arithmeticElement$ebnf$1\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"arithmeticElement\", \"symbols\": [\"arithmeticElement$ebnf$1\", \"element\"], \"postprocess\": extractUnaryOperator},\n    {\"name\": \"element\", \"symbols\": [\"function\"], \"postprocess\": id},\n    {\"name\": \"element\", \"symbols\": [\"type\", \"condition\"], \"postprocess\": formatQuery},\n    {\"name\": \"element\", \"symbols\": [\"number\"], \"postprocess\": extractNumber},\n    {\"name\": \"element$string$1\", \"symbols\": [{\"literal\":\"p\"}, {\"literal\":\"i\"}, {\"literal\":\"(\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"element\", \"symbols\": [\"element$string$1\", \"_\", {\"literal\":\")\"}], \"postprocess\": extractPI},\n    {\"name\": \"type$string$1\", \"symbols\": [{\"literal\":\"t\"}, {\"literal\":\"s\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"type\", \"symbols\": [\"type$string$1\"], \"postprocess\": id},\n    {\"name\": \"type$string$2\", \"symbols\": [{\"literal\":\"T\"}, {\"literal\":\"S\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"type\", \"symbols\": [\"type$string$2\"], \"postprocess\": ([d]) => d.toLowerCase()},\n    {\"name\": \"condition\", \"symbols\": [\"curl\", \"CURL\"], \"postprocess\": emptyArray},\n    {\"name\": \"condition$ebnf$1\", \"symbols\": []},\n    {\"name\": \"condition$ebnf$1$subexpression$1\", \"symbols\": [\"comma\", \"pair\"]},\n    {\"name\": \"condition$ebnf$1\", \"symbols\": [\"condition$ebnf$1\", \"condition$ebnf$1$subexpression$1\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"condition\", \"symbols\": [\"curl\", \"pair\", \"condition$ebnf$1\", \"CURL\"], \"postprocess\": extractConditionToArray},\n    {\"name\": \"string\", \"symbols\": [\"sqstring\"], \"postprocess\": id},\n    {\"name\": \"string\", \"symbols\": [\"dqstring\"], \"postprocess\": id},\n    {\"name\": \"string\", \"symbols\": [\"variable\"], \"postprocess\": id},\n    {\"name\": \"regexp_string\", \"symbols\": [\"sqregexp\"], \"postprocess\": id},\n    {\"name\": \"regexp_string\", \"symbols\": [\"dqregexp\"], \"postprocess\": id},\n    {\"name\": \"regexp_string\", \"symbols\": [\"variable\"], \"postprocess\": id},\n    {\"name\": \"array\", \"symbols\": [\"sqr\", \"SQR\"], \"postprocess\": emptyArray},\n    {\"name\": \"array$ebnf$1\", \"symbols\": []},\n    {\"name\": \"array$ebnf$1$subexpression$1\", \"symbols\": [\"comma\", \"value\"]},\n    {\"name\": \"array$ebnf$1\", \"symbols\": [\"array$ebnf$1\", \"array$ebnf$1$subexpression$1\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"array\", \"symbols\": [\"sqr\", \"value\", \"array$ebnf$1\", \"SQR\"], \"postprocess\": extractArray},\n    {\"name\": \"object\", \"symbols\": [\"curl\", \"CURL\"], \"postprocess\": emptyObject},\n    {\"name\": \"object$ebnf$1\", \"symbols\": []},\n    {\"name\": \"object$ebnf$1$subexpression$1\", \"symbols\": [\"comma\", \"pair\"]},\n    {\"name\": \"object$ebnf$1\", \"symbols\": [\"object$ebnf$1\", \"object$ebnf$1$subexpression$1\"], \"postprocess\": (d) => d[0].concat([d[1]])},\n    {\"name\": \"object\", \"symbols\": [\"curl\", \"pair\", \"object$ebnf$1\", \"CURL\"], \"postprocess\": extractObject},\n    {\"name\": \"pair\", \"symbols\": [\"prop_name\", \"_\", \"equals\", \"_\", \"value\"], \"postprocess\": d => ([d[0], d[2], d[4]])},\n    {\"name\": \"pair\", \"symbols\": [\"prop_name\", \"_\", \"not_equals\", \"_\", \"primitive\"], \"postprocess\": d => ([d[0], d[2], d[4]])},\n    {\"name\": \"pair\", \"symbols\": [\"prop_name\", \"_\", \"regexp\", \"_\", \"regexp_string\"], \"postprocess\": d => ([d[0], d[2], d[4]])},\n    {\"name\": \"variable\", \"symbols\": [{\"literal\":\"$\"}, \"prop_name\"], \"postprocess\": joinArr},\n    {\"name\": \"variable$string$1\", \"symbols\": [{\"literal\":\"[\"}, {\"literal\":\"[\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"variable$string$2\", \"symbols\": [{\"literal\":\"]\"}, {\"literal\":\"]\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"variable\", \"symbols\": [\"variable$string$1\", \"prop_name\", \"variable$string$2\"], \"postprocess\": joinArr},\n    {\"name\": \"variable\", \"symbols\": [{\"literal\":\"$\"}, \"advanced_variable\"], \"postprocess\": joinArr},\n    {\"name\": \"advanced_variable\", \"symbols\": [{\"literal\":\"{\"}, \"prop_name\", {\"literal\":\":\"}, \"prop_name\", {\"literal\":\"}\"}], \"postprocess\": joinArr},\n    {\"name\": \"unary_operator\", \"symbols\": [\"_\", {\"literal\":\"-\"}, \"_\"], \"postprocess\": extractOperator},\n    {\"name\": \"operator\", \"symbols\": [\"_\", {\"literal\":\"+\"}, \"_\"], \"postprocess\": extractOperator},\n    {\"name\": \"operator\", \"symbols\": [\"_\", {\"literal\":\"-\"}, \"_\"], \"postprocess\": extractOperator},\n    {\"name\": \"operator\", \"symbols\": [\"_\", {\"literal\":\"/\"}, \"_\"], \"postprocess\": extractOperator},\n    {\"name\": \"operator\", \"symbols\": [\"_\", {\"literal\":\"*\"}, \"_\"], \"postprocess\": extractOperator},\n    {\"name\": \"comma\", \"symbols\": [\"_\", {\"literal\":\",\"}, \"_\"], \"postprocess\": d => d[1]},\n    {\"name\": \"unary$string$1\", \"symbols\": [{\"literal\":\"s\"}, {\"literal\":\"i\"}, {\"literal\":\"n\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"unary\", \"symbols\": [\"unary$string$1\"], \"postprocess\": id},\n    {\"name\": \"unary$string$2\", \"symbols\": [{\"literal\":\"c\"}, {\"literal\":\"o\"}, {\"literal\":\"s\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"unary\", \"symbols\": [\"unary$string$2\"], \"postprocess\": id},\n    {\"name\": \"unary$string$3\", \"symbols\": [{\"literal\":\"l\"}, {\"literal\":\"n\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"unary\", \"symbols\": [\"unary$string$3\"], \"postprocess\": id},\n    {\"name\": \"unary$string$4\", \"symbols\": [{\"literal\":\"s\"}, {\"literal\":\"q\"}, {\"literal\":\"r\"}, {\"literal\":\"t\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"unary\", \"symbols\": [\"unary$string$4\"], \"postprocess\": id},\n    {\"name\": \"unary$string$5\", \"symbols\": [{\"literal\":\"e\"}, {\"literal\":\"x\"}, {\"literal\":\"p\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"unary\", \"symbols\": [\"unary$string$5\"], \"postprocess\": id},\n    {\"name\": \"unary$string$6\", \"symbols\": [{\"literal\":\"a\"}, {\"literal\":\"b\"}, {\"literal\":\"s\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"unary\", \"symbols\": [\"unary$string$6\"], \"postprocess\": id},\n    {\"name\": \"unary\", \"symbols\": [], \"postprocess\": id},\n    {\"name\": \"binary$string$1\", \"symbols\": [{\"literal\":\"p\"}, {\"literal\":\"o\"}, {\"literal\":\"w\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"binary\", \"symbols\": [\"binary$string$1\"], \"postprocess\": id},\n    {\"name\": \"binary$string$2\", \"symbols\": [{\"literal\":\"r\"}, {\"literal\":\"o\"}, {\"literal\":\"u\"}, {\"literal\":\"n\"}, {\"literal\":\"d\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"binary\", \"symbols\": [\"binary$string$2\"], \"postprocess\": id},\n    {\"name\": \"binary$string$3\", \"symbols\": [{\"literal\":\"o\"}, {\"literal\":\"n\"}, {\"literal\":\"_\"}, {\"literal\":\"e\"}, {\"literal\":\"r\"}, {\"literal\":\"r\"}, {\"literal\":\"o\"}, {\"literal\":\"r\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"binary\", \"symbols\": [\"binary$string$3\"], \"postprocess\": id},\n    {\"name\": \"n_ary$string$1\", \"symbols\": [{\"literal\":\"m\"}, {\"literal\":\"a\"}, {\"literal\":\"x\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"n_ary\", \"symbols\": [\"n_ary$string$1\"], \"postprocess\": id},\n    {\"name\": \"n_ary$string$2\", \"symbols\": [{\"literal\":\"m\"}, {\"literal\":\"i\"}, {\"literal\":\"n\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"n_ary\", \"symbols\": [\"n_ary$string$2\"], \"postprocess\": id},\n    {\"name\": \"n_ary$string$3\", \"symbols\": [{\"literal\":\"a\"}, {\"literal\":\"v\"}, {\"literal\":\"g\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"n_ary\", \"symbols\": [\"n_ary$string$3\"], \"postprocess\": id},\n    {\"name\": \"n_ary$string$4\", \"symbols\": [{\"literal\":\"s\"}, {\"literal\":\"u\"}, {\"literal\":\"m\"}], \"postprocess\": (d) => d.join('')},\n    {\"name\": \"n_ary\", \"symbols\": [\"n_ary$string$4\"], \"postprocess\": id},\n    {\"name\": \"br\", \"symbols\": [\"_\", {\"literal\":\"(\"}], \"postprocess\": null},\n    {\"name\": \"BR\", \"symbols\": [\"_\", {\"literal\":\")\"}], \"postprocess\": null},\n    {\"name\": \"curl\", \"symbols\": [\"_\", {\"literal\":\"{\"}], \"postprocess\": null},\n    {\"name\": \"CURL\", \"symbols\": [\"_\", {\"literal\":\"}\"}], \"postprocess\": null},\n    {\"name\": \"sqr\", \"symbols\": [\"_\", {\"literal\":\"[\"}], \"postprocess\": null},\n    {\"name\": \"SQR\", \"symbols\": [\"_\", {\"literal\":\"]\"}], \"postprocess\": null}\n  ],\n  ParserStart: \"query\",\n};\n\nexport default grammar;\n","import {\n  RequestParams,\n  Response,\n  HttpMethod,\n  DataSourceRequestOptions,\n  Items,\n  CursorResponse,\n  Limit,\n  isError,\n} from './types';\nimport { getQueryString } from './utils';\nimport { BackendSrv } from 'grafana/app/core/services/backend_srv';\nimport { chunk } from 'lodash';\nimport { CacheTime } from './constants';\nimport ms from 'ms';\n\nexport class Connector {\n  public constructor(\n    private project: string,\n    private apiUrl: string,\n    private backendSrv: BackendSrv\n  ) {}\n\n  cachedRequests = new Map<String, Promise<any>>();\n\n  private fetchData<T>(request: RequestParams): Promise<T> {\n    const { path, data, method, params, requestId, cacheTime } = request;\n    const queryString = params ? `?${getQueryString(params)}` : '';\n    const url = `${this.apiUrl}/cogniteapi/${this.project}${path}${queryString}`;\n    const body: DataSourceRequestOptions = { url, data, method };\n    if (requestId) {\n      body.requestId = requestId;\n    }\n    return this.cachedRequest(body, cacheTime);\n  }\n\n  public async chunkAndFetch<Req extends Items, Res extends Response>(\n    request: RequestParams<Req>,\n    chunkSize: number = 100\n  ): Promise<Res> {\n    const { data, requestId } = request;\n    const chunkedItems = chunk(data.items, chunkSize);\n    const chunkedRequests = chunkedItems.map((items, i) => ({\n      ...request,\n      ...chunkedReqId(requestId, i),\n      data: {\n        ...data,\n        items,\n      },\n    }));\n    const promises = chunkedRequests.map(chunk => this.fetchData<Res>(chunk));\n    const results = await Promise.all(promises);\n    const mergedItems = results.reduce((all, { data }) => {\n      return [...all, ...data.items];\n    }, []);\n    return {\n      ...results[0],\n      data: {\n        ...results[0].data,\n        items: mergedItems,\n      },\n    };\n  }\n\n  public async fetchItems<T>(params: RequestParams): Promise<T[]> {\n    const { data } = await this.fetchData<Response<T>>(params);\n    return data.items;\n  }\n\n  public async fetchAndPaginate<T>(params: RequestParams<Limit>) {\n    const maxLimit = 1000;\n    const { data: queryData } = params;\n    const fullLimit = queryData.limit || maxLimit;\n    const { data } = await this.fetchData<CursorResponse<T>>({\n      ...params,\n      data: {\n        ...queryData,\n        limit: Math.min(maxLimit, fullLimit),\n      },\n    });\n    let { nextCursor: cursor, items } = data;\n    while (cursor && fullLimit > items.length) {\n      const { data: current } = await this.fetchData<CursorResponse<T>>({\n        ...params,\n        data: {\n          ...queryData,\n          cursor,\n          limit: maxLimit,\n        },\n      });\n      cursor = current.nextCursor;\n      items = [...items, ...current.items];\n    }\n    if (items.length > fullLimit) {\n      items.length = fullLimit;\n    }\n    return items;\n  }\n\n  public request({ path, method = HttpMethod.GET }: { path: string; method?: HttpMethod }) {\n    return this.backendSrv.datasourceRequest({\n      method,\n      url: `${this.apiUrl}/${path}`,\n    });\n  }\n\n  public cachedRequest = async (\n    query: DataSourceRequestOptions,\n    cacheTime: string = CacheTime.Default\n  ): Promise<any> => {\n    const { requestId, ...queryWithoutId } = query;\n    const hash = JSON.stringify(queryWithoutId);\n    const timeout = ms(cacheTime);\n\n    if (this.cachedRequests.has(hash)) {\n      return this.cachedRequests.get(hash);\n    }\n\n    const request = (async () => {\n      try {\n        const res = await this.backendSrv.datasourceRequest(query);\n        if (isError(res)) {\n          throw res;\n        }\n        setTimeout(() => this.cachedRequests.delete(hash), timeout);\n        return res;\n      } catch (e) {\n        this.cachedRequests.delete(hash);\n        throw e;\n      }\n    })();\n\n    this.cachedRequests.set(hash, request);\n    return request;\n  };\n}\n\nconst chunkedReqId = (requestId: string, chunk: number) => {\n  return requestId\n    ? {\n        requestId: chunk ? `${requestId}${chunk}` : requestId,\n      }\n    : undefined;\n};\n","import _ from 'lodash';\nimport { QueryCtrl } from 'grafana/app/plugins/sdk';\nimport { appEvents } from 'grafana/app/core/core';\nimport './css/query_editor.css';\nimport CogniteDatasource from './datasource';\nimport { Tab, QueryTarget, QueryDatapointsWarning, QueryRequestError } from './types';\nimport { datapointsWarningEvent, failedResponseEvent } from './constants';\n\nexport class CogniteQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  target: QueryTarget;\n  assetVals: any;\n  datasource: CogniteDatasource;\n  panelCtrl: any;\n  aggregation = [\n    { value: 'none', name: 'None' },\n    { value: 'average', name: 'Average' },\n    { value: 'max', name: 'Max' },\n    { value: 'min', name: 'Min' },\n    { value: 'count', name: 'Count' },\n    { value: 'sum', name: 'Sum' },\n    { value: 'interpolation', name: 'Interpolation' },\n    { value: 'stepInterpolation', name: 'Step Interpolation' },\n    { value: 'continuousVariance', name: 'Continuous Variance' },\n    { value: 'discreteVariance', name: 'Discrete Variance' },\n    { value: 'totalVariation', name: 'Total Variation' },\n  ];\n  customTabAggregation = [\n    { value: 'none', name: 'None' },\n    { value: 'average', name: 'Average' },\n    { value: 'interpolation', name: 'Interpolation' },\n    { value: 'stepInterpolation', name: 'Step Interpolation' },\n  ];\n  tabs = [\n    {\n      value: Tab.Timeseries,\n      name: 'Select Timeseries',\n      src: 'timeseriestab.html',\n    },\n    {\n      value: Tab.Asset,\n      name: 'Select Timeseries from Asset',\n      src: 'assettab.html',\n    },\n    { value: Tab.Custom, name: 'Custom Query', src: 'customtab.html' },\n  ];\n  currentTabIndex: number;\n  defaults = {\n    target: '',\n    type: 'timeserie',\n    aggregation: 'average',\n    granularity: '',\n    label: '',\n    tab: Tab.Timeseries,\n    expr: '',\n    assetQuery: {\n      target: '',\n      old: undefined,\n      includeSubtrees: false,\n    },\n  };\n\n  /** @ngInject **/\n  constructor($scope, $injector, private templateSrv) {\n    super($scope, $injector);\n\n    _.defaultsDeep(this.target, this.defaults);\n\n    this.currentTabIndex = this.tabs.findIndex(x => x.value === this.target.tab) || 0;\n\n    appEvents.on(failedResponseEvent, this.handleError);\n    appEvents.on(datapointsWarningEvent, this.handleWarning);\n  }\n\n  handleWarning = ({ refId, warning }: QueryDatapointsWarning) => {\n    if (this.target.refId === refId) {\n      this.target.warning = warning;\n    }\n  };\n\n  handleError = ({ refId, error }: QueryRequestError) => {\n    if (this.target.refId === refId) {\n      this.target.error = error;\n    }\n  };\n\n  getOptions(query: string, type: string) {\n    return this.datasource.getOptionsForDropdown(query || '', type).then(options => {\n      _.defer(() => this.$scope.$digest()); // need to force the update on the dropdown\n      return options;\n    });\n  }\n\n  refreshData() {\n    this.onChangeQuery();\n    this.refresh(); // Asks the panel to refresh data.\n  }\n\n  onChangeQuery() {\n    if (this.target.error) {\n      this.target.error = '';\n    }\n    if (this.target.warning) {\n      this.target.warning = '';\n    }\n  }\n\n  changeTab(index: number) {\n    this.currentTabIndex = index;\n    this.target.tab = this.tabs[index].value;\n    this.refresh();\n  }\n\n  getCollapsedText() {\n    if (this.target.tab === Tab.Timeseries) {\n      return `Timeseries: ${this.target.target} ${this.target.error}`;\n    }\n    if (this.target.tab === Tab.Asset) {\n      return `Timeseries from Asset: ${this.target.assetQuery.target} ${this.target.error}`;\n    }\n    if (this.target.tab === Tab.Custom) {\n      return `Custom Query: ${this.target.expr} ${this.target.error}`;\n    }\n    return '';\n  }\n\n  getInitAggregate() {\n    if (_.findIndex(this.customTabAggregation, ['value', this.target.aggregation]) === -1) {\n      this.target.aggregation = this.customTabAggregation[0].value;\n      this.refresh();\n    }\n  }\n\n  $onDestroy() {\n    appEvents.off(failedResponseEvent, this.handleError);\n    appEvents.off(datapointsWarningEvent, this.handleWarning);\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__34__;","\nvar content = require(\"!!../../node_modules/css-loader/dist/cjs.js??ref--5-1!./query_editor.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/dist/cjs.js??ref--5-1!./query_editor.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/dist/cjs.js??ref--5-1!./query_editor.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","exports = module.exports = require(\"../../node_modules/css-loader/dist/runtime/api.js\")(true);\n// Module\nexports.push([module.id, \".min-width-10 {\\n  min-width: 10rem;\\n}\\n\\n.min-width-12 {\\n  min-width: 12rem;\\n}\\n\\n.min-width-20 {\\n  min-width: 20rem;\\n}\\n\\n.gf-form-select-wrapper select.gf-form-input {\\n  height: 2.64rem;\\n}\\n\\n.gf-form-select-wrapper--caret-indent.gf-form-select-wrapper::after {\\n  right: 0.775rem;\\n}\\n\\n.gf-tabs-cognite.active:before,\\n.gf-tabs-cognite.active:focus:before,\\n.gf-tabs-cognite.active:hover:before {\\n  background-image: linear-gradient(90deg, #33b5e5 0, #00b3ff 99%, #1b1b1b);\\n}\\n\\ninput[type='checkbox'] {\\n  margin: 4px;\\n}\\n\\n.custom-query {\\n  font-family: monospace;\\n}\\n\\npre code {\\n  line-height: 2;\\n}\\n\\n.cognite-timeseries-list-checkbox {\\n  margin-right: 10px;\\n}\\n\\n.gf-dropdown-wrapper {\\n  min-width: 200px;\\n}\\n\\npre.gf-formatted-error,\\npre.gf-formatted-warning {\\n  background: transparent;\\n  border: none;\\n  padding-bottom: 0;\\n  color: #ff6060;\\n}\\n\\npre.gf-formatted-warning {\\n  color: #f79520;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"query_editor.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,eAAe;AACjB;;AAEA;;;EAGE,yEAAyE;AAC3E;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;;EAEE,uBAAuB;EACvB,YAAY;EACZ,iBAAiB;EACjB,cAAc;AAChB;;AAEA;EACE,cAAc;AAChB\",\"file\":\"query_editor.css\",\"sourcesContent\":[\".min-width-10 {\\n  min-width: 10rem;\\n}\\n\\n.min-width-12 {\\n  min-width: 12rem;\\n}\\n\\n.min-width-20 {\\n  min-width: 20rem;\\n}\\n\\n.gf-form-select-wrapper select.gf-form-input {\\n  height: 2.64rem;\\n}\\n\\n.gf-form-select-wrapper--caret-indent.gf-form-select-wrapper::after {\\n  right: 0.775rem;\\n}\\n\\n.gf-tabs-cognite.active:before,\\n.gf-tabs-cognite.active:focus:before,\\n.gf-tabs-cognite.active:hover:before {\\n  background-image: linear-gradient(90deg, #33b5e5 0, #00b3ff 99%, #1b1b1b);\\n}\\n\\ninput[type='checkbox'] {\\n  margin: 4px;\\n}\\n\\n.custom-query {\\n  font-family: monospace;\\n}\\n\\npre code {\\n  line-height: 2;\\n}\\n\\n.cognite-timeseries-list-checkbox {\\n  margin-right: 10px;\\n}\\n\\n.gf-dropdown-wrapper {\\n  min-width: 200px;\\n}\\n\\npre.gf-formatted-error,\\npre.gf-formatted-warning {\\n  background: transparent;\\n  border: none;\\n  padding-bottom: 0;\\n  color: #ff6060;\\n}\\n\\npre.gf-formatted-warning {\\n  color: #f79520;\\n}\\n\"]}]);\n\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return '@media ' + item[2] + '{' + content + '}';\n      } else {\n        return content;\n      }\n    }).join('');\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","export class CogniteConfigCtrl {\n  static templateUrl = 'partials/config.html';\n  current: any;\n\n  /** @ngInject **/\n  constructor($scope) {}\n}\n","import { Annotation } from './types';\nimport CogniteDatasource from './datasource';\nimport { parse } from './parser/events-assets';\n\nexport class CogniteAnnotationsQueryCtrl {\n  public static templateUrl = 'partials/annotations.editor.html';\n  annotation: Annotation;\n  datasource: CogniteDatasource;\n\n  /** @ngInject */\n  constructor() {}\n\n  onBlur() {\n    this.annotation.error = '';\n\n    try {\n      const withReplacedVariable = this.datasource.replaceVariable(this.annotation.query);\n      parse(withReplacedVariable);\n    } catch ({ message }) {\n      this.annotation.error = message;\n    }\n  }\n}\n","import React from 'react';\nimport { VariableQueryData, VariableQueryProps } from './types';\nimport { parse } from './parser/events-assets';\n\nconst help = (\n  <pre>\n    Variable query uses the{' '}\n    <a\n      className=\"query-keyword\"\n      href=\"https://docs.cognite.com/api/v1/#operation/listAssets\"\n      target=\"_blank\"\n    >\n      assets/list\n    </a>{' '}\n    endpoint for data fetching. <code className=\"query-keyword\">'='</code> sign is used to provide\n    parameters for the request.\n    <br />\n    Format: <code className=\"query-keyword\">{`assets{param=value,...}`}</code>\n    <br />\n    Example:{' '}\n    <code className=\"query-keyword\">{`assets{assetSubtreeIds=[{id=123}, {externalId='external'}]}`}</code>\n    <br />\n    <br />\n    Results filtering is also possible by adding <code className=\"query-keyword\">'=~'</code>,{' '}\n    <code className=\"query-keyword\">'!~'</code> and <code className=\"query-keyword\">'!='</code>{' '}\n    signs to props. Applying few filters for query acts as logic AND\n    <br />\n    Format:\n    <br />\n    <code className=\"query-keyword\">'=~'</code> – regex equality, means that provided regexp is used\n    to match defined prop and matched value will be included\n    <br />\n    <code className=\"query-keyword\">'!~'</code> – regex inequality, means that provided regexp is\n    used to match defined prop and matched value will be excluded\n    <br />\n    <code className=\"query-keyword\">'!='</code> – strict inequality, means that provided string is\n    used to strict prop comparing and matched value will be excluded\n    <br />\n    Example:{' '}\n    <code className=\"query-keyword\">{`assets{metadata={KEY='value', KEY_2=~'value.*'}, assetSubtreeIds=[{id=123}]}`}</code>\n    To learn more about the querying capabilities of Cognite Data Source for Grafana, please visit\n    our{' '}\n    <a\n      className=\"query-keyword\"\n      href=\"https://docs.cognite.com/cdf/dashboards/guides/grafana/getting_started.html\"\n    >\n      documentation\n    </a>\n    .\n  </pre>\n);\n\nexport class CogniteVariableQueryCtrl extends React.PureComponent<\n  VariableQueryProps,\n  VariableQueryData\n> {\n  defaults: VariableQueryData = {\n    query: '',\n    error: '',\n  };\n\n  constructor(props: VariableQueryProps) {\n    super(props);\n    this.state = Object.assign(this.defaults, this.props.query);\n  }\n\n  handleQueryChange = event => {\n    this.setState({ query: event.target.value, error: '' });\n  };\n\n  handleBlur = () => {\n    try {\n      const { query } = this.state;\n      parse(query);\n\n      this.props.onChange({ query }, query);\n    } catch ({ message }) {\n      this.setState({ error: message });\n      this.props.onChange({ query: '' }, '');\n    }\n  };\n\n  render() {\n    return (\n      <div>\n        <div className=\"gf-form gf-form--grow\">\n          <span className=\"gf-form-label query-keyword fix-query-keyword width-10\">Query</span>\n          <input\n            type=\"text\"\n            className=\"gf-form-input\"\n            value={this.state.query}\n            onChange={this.handleQueryChange}\n            onBlur={this.handleBlur}\n            placeholder=\"eg: assets{name='example', assetSubtreeIds=[{id=123456789, externalId='externalId'}]}\"\n          />\n        </div>\n        <div className=\"gf-form--grow\">\n          {this.state.error ? <pre className=\"gf-formatted-error\">{this.state.error}</pre> : null}\n          {help}\n        </div>\n      </div>\n    );\n  }\n}\n"],"sourceRoot":""}