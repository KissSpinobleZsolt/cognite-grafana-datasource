{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./types.ts","webpack:///external \"lodash\"","webpack:///./utils.ts","webpack:///./module.ts","webpack:///./datasource.ts","webpack:///./cache.ts","webpack:///./parser.ts","webpack:///./query_ctrl.ts","webpack:///external \"app/plugins/sdk\"","webpack:///./css/query_editor.css?f712","webpack:///./css/query_editor.css","webpack:///../node_modules/css-loader/dist/runtime/api.js","webpack:///../node_modules/style-loader/lib/addStyles.js","webpack:///../node_modules/style-loader/lib/urls.js","webpack:///./config_ctrl.ts","webpack:///./annotation_ctrl.ts","webpack:///./variable_query_ctrl.tsx"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Tab","ParseType","isError","maybeError","undefined","error","FilterType","__WEBPACK_EXTERNAL_MODULE__1__","lodash_1","__importDefault","types_1","Utils","getQueryString","obj","default","reduce","result","val","isNil","isArray","map","encodeURIComponent","join","slice","getDatasourceValueString","aggregation","","none","avg","int","stepinterpolation","step","continuousvariance","continuousVariance","cv","discretevariance","dv","totalvariation","tv","getAggregationDropdownString","splitFilters","filterString","filtersOptions","onlyAllowEquals","filterStrings","openChars","closeChars","start","length","filter","substring","trim","match","indexOf","push","findIndex","x","c_1","out_i_1","applyFilters","filters","objects","_i","objects_1","selected","_a","filters_1","type","RegexEquals","regex","RegexNotEquals","NotEquals","String","Equals","intervalToGranularity","intervalMs","seconds","Math","round","minutes","hours","timeseriesHash","options","target","dashboardId","panelId","refId","assetQuery","templatedTarget","includeSubtrees","datasource_1","Datasource","query_ctrl_1","QueryCtrl","CogniteQueryCtrl","config_ctrl_1","ConfigCtrl","CogniteConfigCtrl","annotation_ctrl_1","AnnotationsQueryCtrl","CogniteAnnotationsQueryCtrl","variable_query_ctrl_1","VariableQueryEditor","CogniteVariableQueryCtrl","dateMath","__importStar","utils_1","cache_1","parser_1","CogniteDatasource","instanceSettings","backendSrv","templateSrv","this","id","url","project","jsonData","cogniteProject","$inject","queryTargets","targets","warning","hide","tab","Timeseries","Asset","Custom","concat","Promise","resolve","data","timeFrom","ceil","parse","range","from","timeTo","to","targetQueriesCount","labels","dataQueryRequestPromises","queryTargets_1","getDataQueryRequestItems","dataQueryRequestItems","_d","sent","qlChunks","chunk","queryList","qlChunks_1","qlChunk","count","queryReq","items","end","aggregates","granularity","function","idsCount","idRegex","qlChunk_1","q","matches","idsObj","_b","matches_1","substr","keys","usesAggregates","some","item","aliases","limit","floor","queries","label","trys","this_1","getTimeseries","ts","timeseries","forEach","_this","getTimeseriesLabel","count_1","ql","_c","replace","scopedVars","queryRequests","getQuery","method","catch","datapoints","response","find","errmsg","status","message","config","aggregationPrefix","timestamp","expr","parseExpression","e","annotation","startTime","endTime","queryOptions","Event","console","filterOptions","queryParams","__assign","maxStartTime","minEndTime","events","event","isRegion","text","description","time","timeEnd","title","__generator","urlEnd","query","then","timeSeriesResponseItem","assetId","searchQuery","path","ts_1","setTimeseries","old","splice","cloneDeep","isString","assets","asset","full","group","testDatasource","datasourceRequest","loggedIn","results","Map","requests","stringQuery","JSON","stringify","has","promise","res","set","setTimeout","delete","assetTimeseries","cache","trimmedExpr","isSimpleTimeseriesExpression","getAndApplyFilterOptions","exprWithSpecialFunctions","parseSpecialFunctions","createDataQueryRequestItems","newExpr","funcRegexMatches","_loop_1","matchIndex","timeseriesString","findTimeseriesString","charAt","actualMatchString","selectedTs","funcString","toLowerCase","getTempAliasString","funcRegexMatches_1","dataItems","selectedTs_1","replaceString","tsFiltersString","index","similarTimeseriesString","similarFilterOptions","updateAliases","withAggregateAndGranularity","timeseriesIndex","startIndex","openBracketCount","endQuote","closeBracketIndex","queryItem","regexMatches","_loop_2","aliasParts","split","string","alias","Number","aggregate","regexMatches_1","customQuery","variables","templateVariable","current","splitfilters","timeseriesMatch","assetMatch","filterMatch","splitfilters_1","f","splitAggregation","sdk_1","_super","$scope","$injector","tabs","src","defaults","func","defaultsDeep","currentTabIndex","isAllSelected","every","__extends","getOptions","datasource","getOptionsForDropdown","defer","$digest","onChangeInternal","refresh","changeTab","toggleCheckboxes","selectOption","getCollapsedText","templateUrl","content","hmr","insertInto","locals","list","toString","useSourceMap","cssMapping","btoa","sourceMapping","sourceMap","unescape","sourceURLs","sources","source","sourceRoot","cssWithMappingToString","mediaQuery","alreadyImportedModules","memo","stylesInDom","isOldIE","fn","apply","arguments","parent","styleTarget","querySelector","window","HTMLIFrameElement","contentDocument","head","singleton","stylesInsertedAtTop","fixUrls","addStylesToDom","styles","domStyle","refs","j","parts","addStyle","listToStyles","newStyles","base","part","css","media","getElement","lastStyleElementInsertedAtTop","insertAt","nextSibling","insertBefore","style","appendChild","firstChild","before","Error","removeStyleElement","parentNode","removeChild","idx","document","createElement","attrs","nonce","getNonce","insertStyleElement","addAttrs","el","setAttribute","update","remove","transform","styleIndex","singletonCounter","createStyleElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","link","rel","createLinkElement","autoFixUrls","convertToAbsoluteUrls","blob","oldSrc","href","styleSheet","cssText","createTextNode","newObj","DEBUG","mayRemove","newList","textStore","replacement","Boolean","replaceText","childNodes","cssNode","location","currentDir","baseUrl","pathname","fullMatch","origUrl","newUrl","unquotedOrigUrl","$1","test","mod","verify","errorObj","react_1","props","state","assign","handleChange","prop","setState","handleBlur","onChange","render","className","onBlur","placeholder","required"],"mappings":"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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","import {\r\n  DataQueryOptions,\r\n  DataQuery,\r\n  TimeSeries,\r\n  TimeRange,\r\n  RawTimeRange,\r\n  DataSourceSettings,\r\n} from '@grafana/ui';\r\n\r\nexport interface QueryResponse {\r\n  data: TimeSeries[];\r\n}\r\n\r\nexport interface MetricDescription {\r\n  readonly text: string;\r\n  readonly value: number | string;\r\n}\r\n\r\nexport type MetricFindQueryResponse = MetricDescription[];\r\n\r\nexport enum Tab {\r\n  Timeseries = 'Timeseries',\r\n  Asset = 'Asset',\r\n  Custom = 'Custom',\r\n}\r\n\r\nexport enum ParseType {\r\n  Timeseries = 'Timeseries',\r\n  Asset = 'Asset',\r\n  Event = 'Event',\r\n}\r\n\r\nexport interface TimeSeriesResponseItem {\r\n  name: string;\r\n  isString?: boolean;\r\n  metadata?: object;\r\n  unit?: string;\r\n  assetId?: string;\r\n  isStep: boolean;\r\n  description?: string;\r\n  source?: string;\r\n  sourceId?: string;\r\n  id: number;\r\n  createdTime: number;\r\n  lastUpdatedTime: number;\r\n  selected: boolean;\r\n}\r\n\r\nexport interface TimeSeriesResponse {\r\n  data: {\r\n    items: TimeSeriesResponseItem[];\r\n  };\r\n}\r\n\r\nexport interface AssetQuery {\r\n  target: string;\r\n  includeSubtrees: boolean;\r\n  old?: AssetQuery;\r\n  timeseries?: TimeSeriesResponseItem[];\r\n  func?: string;\r\n  templatedTarget?: string;\r\n}\r\n\r\nexport interface QueryTarget extends DataQuery {\r\n  target: string;\r\n  aggregation: string;\r\n  granularity: string;\r\n  error: string;\r\n  label: string;\r\n  tab: Tab;\r\n  assetQuery: AssetQuery;\r\n  expr: string;\r\n  warning: string;\r\n}\r\n\r\nexport type QueryFormat = 'json';\r\n\r\nexport type QueryOptions = DataQueryOptions<QueryTarget>;\r\n\r\nexport type HttpMethod = 'POST' | 'GET' | 'PATCH' | 'DELETE';\r\n\r\nexport interface DataSourceRequestOptions {\r\n  url: string;\r\n  method: HttpMethod;\r\n  retry?: number;\r\n  requestId?: string;\r\n  headers?: { [s: string]: string };\r\n  silent?: boolean;\r\n  data?: DataQueryRequest;\r\n}\r\n\r\nexport interface TimeSeriesDatapoint {\r\n  timestamp: number;\r\n  value: string;\r\n}\r\n\r\nexport interface Datapoint {\r\n  name: string;\r\n  datapoints: TimeSeriesDatapoint[];\r\n}\r\n\r\nexport interface Datapoints {\r\n  items: Datapoint[];\r\n}\r\n\r\nexport interface DataDatapoints {\r\n  data: Datapoints;\r\n}\r\n\r\nexport interface DataQueryRequestResponse {\r\n  data: DataDatapoints;\r\n  config: {\r\n    data: {\r\n      aggregates: string;\r\n      limit: number;\r\n    };\r\n  };\r\n}\r\n\r\nexport type DataQueryError = {\r\n  error: {\r\n    data: {\r\n      error?: {\r\n        message: string;\r\n        notFound?: string[];\r\n      };\r\n    };\r\n    status: number;\r\n  };\r\n};\r\n\r\nexport function isError(maybeError: DataQueryError | any): maybeError is DataQueryError {\r\n  return (<DataQueryError>maybeError).error !== undefined;\r\n}\r\n\r\nexport interface DataQueryAlias {\r\n  alias: string;\r\n  id: number;\r\n  aggregate?: string;\r\n  granularity?: string;\r\n}\r\n\r\nexport interface DataQueryRequestItem {\r\n  name: string;\r\n  start?: string | number;\r\n  end?: string | number;\r\n  limit?: number;\r\n  granularity?: string;\r\n  aggregates?: string;\r\n  function?: string;\r\n  aliases?: DataQueryAlias[];\r\n}\r\n\r\nexport interface DataQueryRequest {\r\n  items: DataQueryRequestItem[];\r\n  start: string | number;\r\n  end: string | number;\r\n  limit?: number;\r\n  aggregates?: string;\r\n  granularity?: string;\r\n}\r\n\r\nexport interface Annotation {\r\n  datasource: string;\r\n  enable: boolean;\r\n  hide: boolean;\r\n  iconColor: string;\r\n  limit: number;\r\n  name: string;\r\n  expr: string;\r\n  filter: string;\r\n  error: string;\r\n  type: string;\r\n  tags: string[];\r\n}\r\n\r\nexport interface AnnotationQueryOptions {\r\n  range: TimeRange;\r\n  rangeRaw: RawTimeRange;\r\n  annotation: Annotation;\r\n  dashboard: number;\r\n}\r\n\r\nexport interface AnnotationResponse {\r\n  annotation: Annotation;\r\n  title: string;\r\n  time: number;\r\n  timeEnd?: number;\r\n  text: string;\r\n  tags?: string[];\r\n  isRegion?: boolean;\r\n}\r\n\r\nexport interface AnnotationSearchQuery {\r\n  description: string;\r\n  type: string;\r\n  subtype: string;\r\n  minStartTime: number;\r\n  maxStartTime: number;\r\n  minEndTime: number;\r\n  maxEndTime: number;\r\n  minCreatedTime: number;\r\n  maxCreatedTime: number;\r\n  minLastUpdatedTime: number;\r\n  maxLastUpdatedTime: number;\r\n  // format is {\"k1\": \"v1\", \"k2\": \"v2\"}\r\n  metadata: string;\r\n  assetIds: number[];\r\n  assetSubtrees: number[];\r\n  sort: 'startTime' | 'endTime' | 'createdTime' | 'lastUpdatedTime';\r\n  dir: 'asc' | 'desc';\r\n  limit: number;\r\n  offset: 0;\r\n}\r\n\r\nexport interface Event {\r\n  id: number;\r\n  startTime: number;\r\n  endTime: number;\r\n  description: string;\r\n  type: string;\r\n  subtype: string;\r\n  assetIds: number[];\r\n  source: string;\r\n  sourceId: string;\r\n}\r\n\r\nexport interface Events {\r\n  items: Event[];\r\n}\r\n\r\nexport interface DataEvents {\r\n  data: Events;\r\n}\r\n\r\nexport interface AnnotationQueryRequestResponse {\r\n  data: DataEvents;\r\n}\r\n\r\nexport interface TimeseriesSearchQuery {\r\n  q: string;\r\n  description: string;\r\n  limit: number;\r\n  includeMetadata: boolean;\r\n  path: string[];\r\n  assetId: string;\r\n}\r\n\r\nexport interface VariableQueryData {\r\n  query: string;\r\n  filter: string;\r\n}\r\n\r\nexport interface VariableQueryProps {\r\n  query: any;\r\n  onChange: (query: any, definition: string) => void;\r\n  datasource: any;\r\n  templateSrv: any;\r\n}\r\n\r\nexport interface CogniteDataSourceSettings extends DataSourceSettings {\r\n  jsonData: {\r\n    authType: string;\r\n    defaultRegion: string;\r\n    cogniteProject: string;\r\n  };\r\n}\r\n\r\nexport enum FilterType {\r\n  Equals = '=',\r\n  NotEquals = '!=',\r\n  RegexEquals = '=~',\r\n  RegexNotEquals = '!~',\r\n}\r\n\r\nexport interface Filter {\r\n  property: string;\r\n  value: string;\r\n  type: FilterType;\r\n}\r\n\r\nexport interface FilterOptions {\r\n  filters: Filter[];\r\n  granularity: string;\r\n  aggregation: string;\r\n  error: string;\r\n}\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","import _ from 'lodash';\r\nimport { Filter, FilterType, QueryOptions, QueryTarget } from './types';\r\n\r\nexport default class Utils {\r\n  // Converts an object to a query string, ignores properties with undefined/null values\r\n  // TODO: maybe clean this up a bit, might break easily\r\n  static getQueryString(obj: any) {\r\n    return _.reduce(\r\n      obj,\r\n      (result: string, val: any, key: string) => {\r\n        return _.isNil(val)\r\n          ? result\r\n          : _.isArray(val)\r\n          ? `${result + [key, val].map(encodeURIComponent).join('=[')}]&`\r\n          : `${result + [key, val].map(encodeURIComponent).join('=')}&` + '';\r\n      },\r\n      ''\r\n    ).slice(0, -1);\r\n  }\r\n\r\n  static getDatasourceValueString(aggregation: string): string {\r\n    const mapping = {\r\n      '': 'value',\r\n      undefined: 'value',\r\n      none: 'value',\r\n      avg: 'average',\r\n      int: 'interpolation',\r\n      stepinterpolation: 'stepInterpolation',\r\n      step: 'stepInterpolation',\r\n      continuousvariance: 'continousVariance', // spelling mistake is intended - will have to change in 0.6\r\n      continuousVariance: 'continousVariance',\r\n      cv: 'continousVariance',\r\n      discretevariance: 'discreteVariance',\r\n      dv: 'discreteVariance',\r\n      totalvariation: 'totalVariation',\r\n      tv: 'totalVariation',\r\n    };\r\n    return mapping[aggregation] || aggregation;\r\n  }\r\n\r\n  static getAggregationDropdownString(aggregation: string): string {\r\n    let val = Utils.getDatasourceValueString(aggregation);\r\n    if (val === 'continousVariance') val = 'continuousVariance';\r\n    // temp 0.5 fix\r\n    else if (val === 'value') val = 'none';\r\n    return val;\r\n  }\r\n\r\n  static splitFilters(filterString: string, filtersOptions: any, onlyAllowEquals: boolean) {\r\n    const filterStrings = [];\r\n    // ignore commas that are within these characters\r\n    const openChars = ['(', '[', '{', \"'\", '\"'];\r\n    const closeChars = [')', ']', '}', \"'\", '\"'];\r\n    let start = 0;\r\n    for (let i = 0; i <= filterString.length; ++i) {\r\n      if (i === filterString.length || filterString[i] === ',') {\r\n        const filter = filterString.substring(start, i).trim();\r\n        if (filter.length === 0) {\r\n          start = i + 1;\r\n          continue;\r\n        }\r\n        if (onlyAllowEquals && !filter.match(/[^!]=[^~]/)) {\r\n          filtersOptions.error = `ERROR: Unable to parse '${filter}'. Only strict equality (=) is allowed.`;\r\n          return undefined;\r\n        }\r\n        if (filter.indexOf('=') === -1 && filter.indexOf('~') === -1) {\r\n          filtersOptions.error = `ERROR: Could not parse: '${filter}'. Missing a comparator (=,!=,=~,!~).`;\r\n          return undefined;\r\n        }\r\n        filterStrings.push(filter);\r\n        start = i + 1;\r\n        continue;\r\n      }\r\n      const o = openChars.findIndex(x => x === filterString[i]);\r\n      if (o >= 0) {\r\n        const c = filterString.indexOf(closeChars[o], i + 1);\r\n        if (c >= 0) {\r\n          i = c;\r\n          continue;\r\n        } else {\r\n          filtersOptions.error = `ERROR: Could not find closing ' ${\r\n            closeChars[o]\r\n          } ' while parsing '${filterString.substring(start)}'.`;\r\n          return undefined;\r\n        }\r\n      }\r\n      const c = closeChars.findIndex(x => x === filterString[i]);\r\n      if (c >= 0) {\r\n        filtersOptions.error = `ERROR: Unexpected character ' ${\r\n          closeChars[c]\r\n        } ' while parsing '${filterString.substring(start)}'.`;\r\n        return undefined;\r\n      }\r\n    }\r\n    return filterStrings;\r\n  }\r\n\r\n  static applyFilters(filters: Filter[], objects: any): void {\r\n    for (const obj of objects) {\r\n      obj.selected = true;\r\n      for (const filter of filters) {\r\n        if (filter.type === FilterType.RegexEquals) {\r\n          const val = _.get(obj, filter.property);\r\n          const regex = `^${filter.value}$`;\r\n          if (val === undefined || !val.match(regex)) {\r\n            obj.selected = false;\r\n            break;\r\n          }\r\n        } else if (filter.type === FilterType.RegexNotEquals) {\r\n          const val = _.get(obj, filter.property);\r\n          const regex = `^${filter.value}$`;\r\n          if (val === undefined || val.match(regex)) {\r\n            obj.selected = false;\r\n            break;\r\n          }\r\n        } else if (filter.type === FilterType.NotEquals) {\r\n          const val = _.get(obj, filter.property);\r\n          if (val === undefined || String(val) === filter.value) {\r\n            obj.selected = false;\r\n            break;\r\n          }\r\n        } else if (filter.type === FilterType.Equals) {\r\n          const val = _.get(obj, filter.property);\r\n          if (val === undefined || String(val) !== filter.value) {\r\n            obj.selected = false;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  static intervalToGranularity(intervalMs: number): string {\r\n    const seconds = Math.round(intervalMs / 1000.0);\r\n    if (seconds <= 60) {\r\n      if (seconds <= 1) {\r\n        return '1s';\r\n      }\r\n      return `${seconds}s`;\r\n    }\r\n    const minutes = Math.round(intervalMs / 1000.0 / 60.0);\r\n    if (minutes < 60) {\r\n      return `${minutes}m`;\r\n    }\r\n    const hours = Math.round(intervalMs / 1000.0 / 60.0 / 60.0);\r\n    if (hours <= 24) {\r\n      return `${hours}h`;\r\n    }\r\n    const days = Math.round(intervalMs / 1000.0 / 60.0 / 60.0 / 24.0);\r\n    return `${days}d`;\r\n  }\r\n\r\n  static timeseriesHash(options: QueryOptions, target: QueryTarget) {\r\n    return `${options.dashboardId}_${options.panelId}_${target.refId}_${\r\n      target.assetQuery.templatedTarget\r\n    }_${target.assetQuery.includeSubtrees}`;\r\n  }\r\n}\r\n","import CogniteDatasource from './datasource';\r\nimport { CogniteQueryCtrl } from './query_ctrl';\r\nimport { CogniteConfigCtrl } from './config_ctrl';\r\nimport { CogniteAnnotationsQueryCtrl } from './annotation_ctrl';\r\nimport { CogniteVariableQueryCtrl } from './variable_query_ctrl';\r\n\r\nexport {\r\n  CogniteDatasource as Datasource,\r\n  CogniteQueryCtrl as QueryCtrl,\r\n  CogniteConfigCtrl as ConfigCtrl,\r\n  CogniteAnnotationsQueryCtrl as AnnotationsQueryCtrl,\r\n  CogniteVariableQueryCtrl as VariableQueryEditor,\r\n};\r\n","import _ from 'lodash';\r\nimport * as dateMath from 'grafana/app/core/utils/datemath';\r\nimport Utils from './utils';\r\nimport cache from './cache';\r\nimport { parseExpression, parse } from './parser';\r\nimport { BackendSrv } from 'grafana/app/core/services/backend_srv';\r\nimport { TemplateSrv } from 'grafana/app/features/templating/template_srv';\r\nimport {\r\n  AnnotationQueryOptions,\r\n  AnnotationResponse,\r\n  CogniteDataSourceSettings,\r\n  DataQueryError,\r\n  DataQueryRequest,\r\n  DataQueryRequestItem,\r\n  DataQueryRequestResponse,\r\n  MetricFindQueryResponse,\r\n  ParseType,\r\n  QueryOptions,\r\n  QueryResponse,\r\n  QueryTarget,\r\n  Tab,\r\n  TimeSeriesResponse,\r\n  TimeSeriesResponseItem,\r\n  TimeseriesSearchQuery,\r\n  VariableQueryData,\r\n  isError,\r\n} from './types';\r\n\r\nexport default class CogniteDatasource {\r\n  id: number;\r\n  url: string;\r\n  name: string;\r\n  project: string;\r\n\r\n  /** @ngInject */\r\n  constructor(\r\n    instanceSettings: CogniteDataSourceSettings,\r\n    private backendSrv: BackendSrv,\r\n    private templateSrv: TemplateSrv\r\n  ) {\r\n    this.id = instanceSettings.id;\r\n    this.url = instanceSettings.url;\r\n    this.project = instanceSettings.jsonData.cogniteProject;\r\n    this.name = instanceSettings.name;\r\n  }\r\n\r\n  public async query(options: QueryOptions): Promise<QueryResponse> {\r\n    const queryTargets: QueryTarget[] = options.targets.reduce((targets, target) => {\r\n      target.error = '';\r\n      target.warning = '';\r\n      if (\r\n        !target ||\r\n        target.hide ||\r\n        ((target.tab === Tab.Timeseries || target.tab === undefined) &&\r\n          (!target.target || target.target === 'Start typing tag id here')) ||\r\n        ((target.tab === Tab.Asset || target.tab === Tab.Custom) &&\r\n          (!target.assetQuery || target.assetQuery.target === ''))\r\n      ) {\r\n        return targets;\r\n      }\r\n      return targets.concat(target);\r\n    }, []);\r\n\r\n    if (queryTargets.length === 0) {\r\n      return Promise.resolve({ data: [] });\r\n    }\r\n\r\n    const timeFrom = Math.ceil(dateMath.parse(options.range.from));\r\n    const timeTo = Math.ceil(dateMath.parse(options.range.to));\r\n    const targetQueriesCount = [];\r\n    let labels = [];\r\n\r\n    const dataQueryRequestPromises: Promise<DataQueryRequestItem[]>[] = [];\r\n    for (const target of queryTargets) {\r\n      dataQueryRequestPromises.push(this.getDataQueryRequestItems(target, options));\r\n    }\r\n    const dataQueryRequestItems = await Promise.all(dataQueryRequestPromises);\r\n\r\n    const queries: DataQueryRequest[] = [];\r\n    for (const { target, queryList } of dataQueryRequestItems.map((ql, i) => ({\r\n      target: queryTargets[i],\r\n      queryList: ql,\r\n    }))) {\r\n      if (queryList.length === 0 || target.error) {\r\n        continue;\r\n      }\r\n\r\n      // /dataquery is limited to 100 items, so we need to add new calls if we go over 100 items\r\n      // may want to change how much we split into, but for now, 100 seems like the best\r\n      const qlChunks = _.chunk(queryList, 100);\r\n      for (const qlChunk of qlChunks) {\r\n        // keep track of target lengths so we can assign errors later\r\n        targetQueriesCount.push({\r\n          refId: target.refId,\r\n          count: qlChunk.length,\r\n        });\r\n        // create query requests\r\n        const queryReq: DataQueryRequest = {\r\n          items: qlChunk,\r\n          start: timeFrom,\r\n          end: timeTo,\r\n        };\r\n        if (target.aggregation && target.aggregation !== 'none') {\r\n          queryReq.aggregates = target.aggregation;\r\n          if (!target.granularity) {\r\n            queryReq.granularity = Utils.intervalToGranularity(options.intervalMs);\r\n          } else {\r\n            queryReq.granularity = target.granularity;\r\n          }\r\n        }\r\n        if (target.tab === Tab.Custom && qlChunk[0].function) {\r\n          let idsCount = 0;\r\n          const idRegex = /\\[.*?\\]/g; // look for [something]\r\n          for (const q of qlChunk) {\r\n            const matches = q.function.match(idRegex);\r\n            if (!matches) break;\r\n            const idsObj = {};\r\n            for (const match of matches) {\r\n              idsObj[match.substr(1, match.length - 2)] = true;\r\n            }\r\n            idsCount += Object.keys(idsObj).length;\r\n          }\r\n          if (idsCount === 0) idsCount = 1; // will fail anyways, just show the api error message\r\n\r\n          // check if any aggregates are being used\r\n          const usesAggregates = qlChunk.some(item => item.aliases.length > 0);\r\n\r\n          queryReq.limit = Math.floor((usesAggregates ? 10_000 : 100_000) / idsCount);\r\n        } else {\r\n          queryReq.limit = Math.floor((queryReq.aggregates ? 10_000 : 100_000) / qlChunk.length);\r\n        }\r\n        queries.push(queryReq);\r\n      }\r\n\r\n      // assign labels to each timeseries\r\n      if (target.tab === Tab.Timeseries || target.tab === undefined) {\r\n        if (!target.label) target.label = '';\r\n        if (target.label.match(/{{.*}}/)) {\r\n          try {\r\n            // need to fetch the timeseries\r\n            const ts = await this.getTimeseries(\r\n              {\r\n                q: target.target,\r\n                limit: 1,\r\n              },\r\n              target\r\n            );\r\n            labels.push(this.getTimeseriesLabel(target.label, ts[0]));\r\n          } catch {\r\n            labels.push(target.label);\r\n          }\r\n        } else {\r\n          labels.push(target.label);\r\n        }\r\n      } else if (target.tab === Tab.Asset) {\r\n        target.assetQuery.timeseries.forEach(ts => {\r\n          if (ts.selected) {\r\n            if (!target.label) target.label = '';\r\n            labels.push(this.getTimeseriesLabel(target.label, ts));\r\n          }\r\n        });\r\n      } else {\r\n        let count = 0;\r\n        while (count < queryList.length) {\r\n          cache.getTimeseries(options, target).forEach(ts => {\r\n            if (ts.selected && count < queryList.length) {\r\n              count += 1;\r\n              if (!target.label) {\r\n                if (queryList[0].function) {\r\n                  // if using custom functions and no label is specified just use the name of the last timeseries in the function\r\n                  labels.push(ts.name);\r\n                  return;\r\n                }\r\n                target.label = '';\r\n              }\r\n              labels.push(this.getTimeseriesLabel(target.label, ts));\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n    // replace variables in labels as well\r\n    labels = labels.map(label => this.templateSrv.replace(label, options.scopedVars));\r\n\r\n    const queryRequests = queries.map(q =>\r\n      cache\r\n        .getQuery(\r\n          {\r\n            url: `${this.url}/cogniteapi/${this.project}/timeseries/dataquery`,\r\n            method: 'POST',\r\n            data: q,\r\n          },\r\n          this.backendSrv\r\n        )\r\n        .catch(error => {\r\n          return { error };\r\n        })\r\n    );\r\n\r\n    let timeseries: (DataQueryRequestResponse | DataQueryError)[];\r\n    try {\r\n      timeseries = await Promise.all(queryRequests);\r\n    } catch (error) {\r\n      return { data: [] };\r\n    }\r\n    let count = 0;\r\n    return {\r\n      data: timeseries.reduce((datapoints, response, i) => {\r\n        const refId = targetQueriesCount[i].refId;\r\n        const target = queryTargets.find(x => x.refId === refId);\r\n        if (isError(response)) {\r\n          let errmsg: string;\r\n          if (response.error.data && response.error.data.error) {\r\n            errmsg = `[${response.error.status} ERROR] ${response.error.data.error.message}`;\r\n          } else {\r\n            errmsg = 'Unknown error';\r\n          }\r\n          target.error = errmsg;\r\n          count += targetQueriesCount[i].count; // skip over these labels\r\n          return datapoints;\r\n        }\r\n\r\n        const aggregation = response.config.data.aggregates;\r\n        const aggregationPrefix = aggregation ? `${aggregation} ` : '';\r\n        return datapoints.concat(\r\n          response.data.data.items.map(item => {\r\n            if (item.datapoints.length >= response.config.data.limit) {\r\n              target.warning =\r\n                '[WARNING] Datapoints limit was reached, so not all datapoints may be shown. Try increasing the granularity, or choose a smaller time range.';\r\n            }\r\n            return {\r\n              target: labels[count++] ? labels[count - 1] : aggregationPrefix + item.name,\r\n              datapoints: item.datapoints\r\n                .filter(d => d.timestamp >= timeFrom && d.timestamp <= timeTo)\r\n                .map(d => {\r\n                  const val = Utils.getDatasourceValueString(response.config.data.aggregates);\r\n                  return [d[val] === undefined ? d.value : d[val], d.timestamp];\r\n                }),\r\n            };\r\n          })\r\n        );\r\n      }, []),\r\n    };\r\n  }\r\n\r\n  private async getDataQueryRequestItems(\r\n    target: QueryTarget,\r\n    options: QueryOptions\r\n  ): Promise<DataQueryRequestItem[]> {\r\n    if (target.tab === Tab.Timeseries || target.tab === undefined) {\r\n      const query: DataQueryRequestItem = {\r\n        name: target.target,\r\n      };\r\n      return [query];\r\n    }\r\n\r\n    if (target.tab === Tab.Asset) {\r\n      await this.findAssetTimeseries(target, options);\r\n      return target.assetQuery.timeseries.filter(ts => ts.selected).map(ts => ({ name: ts.name }));\r\n    }\r\n\r\n    if (target.tab === Tab.Custom) {\r\n      await this.findAssetTimeseries(target, options);\r\n      // if we don't have any timeseries just return\r\n      if (cache.getTimeseries(options, target).length === 0) {\r\n        target.warning = '[WARNING] No timeseries found.';\r\n        return [];\r\n      }\r\n      if (!target.expr) return [];\r\n      // apply the search expression\r\n      try {\r\n        return parseExpression(\r\n          target.expr,\r\n          options,\r\n          cache.getTimeseries(options, target),\r\n          this.templateSrv,\r\n          target\r\n        );\r\n      } catch (e) {\r\n        target.error = e;\r\n        return [];\r\n      }\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  public async annotationQuery(options: AnnotationQueryOptions): Promise<AnnotationResponse[]> {\r\n    const { range, annotation } = options;\r\n    const { expr, filter, error } = annotation;\r\n    const startTime = Math.ceil(dateMath.parse(range.from));\r\n    const endTime = Math.ceil(dateMath.parse(range.to));\r\n    if (error || !expr) return [];\r\n\r\n    const queryOptions = parse(expr, ParseType.Event, this.templateSrv);\r\n    if (queryOptions.error) {\r\n      console.error(queryOptions.error);\r\n      return [];\r\n    }\r\n    const filterOptions = parse(filter || '', ParseType.Event, this.templateSrv);\r\n    if (filter && filterOptions.error) {\r\n      console.error(filterOptions.error);\r\n      return [];\r\n    }\r\n\r\n    // use maxStartTime and minEndTime so that we include events that are partially in range\r\n    const queryParams = {\r\n      limit: 1000,\r\n      maxStartTime: endTime,\r\n      minEndTime: startTime,\r\n      ...queryOptions.filters.reduce((obj, filter) => {\r\n        obj[filter.property] = filter.value;\r\n        return obj;\r\n      }, {}),\r\n    };\r\n\r\n    const result = await cache.getQuery(\r\n      {\r\n        url: `${this.url}/cogniteapi/${this.project}/events/search?${Utils.getQueryString(\r\n          queryParams\r\n        )}`,\r\n        method: 'GET',\r\n      },\r\n      this.backendSrv\r\n    );\r\n    const events = result.data.data.items;\r\n    if (!events || events.length === 0) return [];\r\n\r\n    Utils.applyFilters(filterOptions.filters, events);\r\n\r\n    return events\r\n      .filter(e => e.selected === true)\r\n      .map(event => ({\r\n        annotation,\r\n        isRegion: true,\r\n        text: event.description,\r\n        time: event.startTime,\r\n        timeEnd: event.endTime,\r\n        title: event.type,\r\n      }));\r\n  }\r\n\r\n  public async getOptionsForDropdown(\r\n    query: string,\r\n    type?: string,\r\n    options?: any\r\n  ): Promise<MetricFindQueryResponse> {\r\n    let urlEnd: string;\r\n    if (type === Tab.Asset) {\r\n      if (query.length === 0) {\r\n        urlEnd = `/cogniteapi/${this.project}/assets?`;\r\n      } else {\r\n        urlEnd = `/cogniteapi/${this.project}/assets/search?query=${query}`;\r\n      }\r\n    } else if (type === Tab.Timeseries) {\r\n      if (query.length === 0) {\r\n        urlEnd = `/cogniteapi/${this.project}/timeseries?`;\r\n      } else {\r\n        urlEnd = `/cogniteapi/${this.project}/timeseries/search?query=${query}`;\r\n      }\r\n    }\r\n    if (options) {\r\n      urlEnd += `&${Utils.getQueryString(options)}`;\r\n    }\r\n\r\n    return cache\r\n      .getQuery(\r\n        {\r\n          url: this.url + urlEnd,\r\n          method: 'GET',\r\n        },\r\n        this.backendSrv\r\n      )\r\n      .then((result: { data: TimeSeriesResponse }) =>\r\n        result.data.data.items.map(timeSeriesResponseItem => ({\r\n          text: timeSeriesResponseItem.description\r\n            ? `${timeSeriesResponseItem.name} (${timeSeriesResponseItem.description})`\r\n            : timeSeriesResponseItem.name,\r\n          value:\r\n            type === Tab.Asset ? String(timeSeriesResponseItem.id) : timeSeriesResponseItem.name,\r\n        }))\r\n      );\r\n  }\r\n\r\n  async findAssetTimeseries(target: QueryTarget, options: QueryOptions): Promise<void> {\r\n    // replace variables with their values\r\n    const assetId = this.templateSrv.replace(target.assetQuery.target, options.scopedVars);\r\n    const searchQuery: Partial<TimeseriesSearchQuery> = {\r\n      path: target.assetQuery.includeSubtrees ? [assetId] : undefined,\r\n      assetId: !target.assetQuery.includeSubtrees ? assetId : undefined,\r\n      limit: 10000,\r\n    };\r\n\r\n    // for custom queries, use cache instead of storing in target object\r\n    if (target.tab === Tab.Custom) {\r\n      target.assetQuery.templatedTarget = assetId;\r\n      const timeseries = cache.getTimeseries(options, target);\r\n      if (!timeseries) {\r\n        const ts = await this.getTimeseries(searchQuery, target);\r\n        cache.setTimeseries(\r\n          options,\r\n          target,\r\n          ts.map(ts => {\r\n            ts.selected = true;\r\n            return ts;\r\n          })\r\n        );\r\n      }\r\n      return Promise.resolve();\r\n    }\r\n\r\n    // check if assetId has changed, if not we do not need to perform this query again\r\n    if (\r\n      target.assetQuery.old &&\r\n      assetId === target.assetQuery.old.target &&\r\n      target.assetQuery.includeSubtrees === target.assetQuery.old.includeSubtrees\r\n    ) {\r\n      return Promise.resolve();\r\n    }\r\n    target.assetQuery.old = {\r\n      target: String(assetId),\r\n      includeSubtrees: target.assetQuery.includeSubtrees,\r\n    };\r\n\r\n    // since /dataquery can only have 100 items and checkboxes become difficult to use past 100 items,\r\n    //  we only get the first 100 timeseries, and show a warning if there are too many timeseries\r\n    searchQuery.limit = 101;\r\n    const ts = await this.getTimeseries(searchQuery, target);\r\n    if (ts.length === 101) {\r\n      target.warning =\r\n        \"[WARNING] Only showing first 100 timeseries. To get better results, either change the selected asset or use 'Custom Query'.\";\r\n      ts.splice(-1);\r\n    }\r\n    target.assetQuery.timeseries = ts.map(ts => {\r\n      ts.selected = true;\r\n      return ts;\r\n    });\r\n  }\r\n\r\n  async getTimeseries(\r\n    searchQuery: Partial<TimeseriesSearchQuery>,\r\n    target: QueryTarget\r\n  ): Promise<TimeSeriesResponseItem[]> {\r\n    return cache\r\n      .getQuery(\r\n        {\r\n          url: `${this.url}/cogniteapi/${this.project}/timeseries?${Utils.getQueryString(\r\n            searchQuery\r\n          )}`,\r\n          method: 'GET',\r\n        },\r\n        this.backendSrv\r\n      )\r\n      .then(\r\n        (result: { data: TimeSeriesResponse }) => {\r\n          return _.cloneDeep(result.data.data.items.filter(ts => !ts.isString));\r\n        },\r\n        error => {\r\n          if (error.data && error.data.error) {\r\n            target.error = `[${error.status} ERROR] ${error.data.error.message}`;\r\n          } else {\r\n            target.error = 'Unknown error';\r\n          }\r\n          return [];\r\n        }\r\n      );\r\n  }\r\n\r\n  // this function is for getting metrics (template variables)\r\n  async metricFindQuery(query: VariableQueryData): Promise<MetricFindQueryResponse> {\r\n    const queryOptions = parse(query.query, ParseType.Asset, this.templateSrv);\r\n    if (queryOptions.error) {\r\n      return [{ text: queryOptions.error, value: '-' }];\r\n    }\r\n    const filterOptions = parse(query.filter, ParseType.Asset, this.templateSrv);\r\n    if (query.filter && filterOptions.error) {\r\n      return [{ text: filterOptions.error, value: '-' }];\r\n    }\r\n    const urlEnd = `/cogniteapi/${this.project}/assets/search?`;\r\n\r\n    const queryParams = {\r\n      limit: 1000,\r\n      ...queryOptions.filters.reduce((obj, filter) => {\r\n        obj[filter.property] = filter.value;\r\n        return obj;\r\n      }, {}),\r\n    };\r\n\r\n    const result = await cache.getQuery(\r\n      {\r\n        url: this.url + urlEnd + Utils.getQueryString(queryParams),\r\n        method: 'GET',\r\n      },\r\n      this.backendSrv\r\n    );\r\n\r\n    const assets = result.data.data.items;\r\n\r\n    // now filter over these assets with the rest of the filters\r\n    Utils.applyFilters(filterOptions.filters, assets);\r\n    const filteredAssets = assets.filter(asset => asset.selected === true);\r\n\r\n    return filteredAssets.map(asset => ({\r\n      text: asset.name,\r\n      value: asset.id,\r\n    }));\r\n  }\r\n\r\n  private getTimeseriesLabel(label: string, timeseries: TimeSeriesResponseItem): string {\r\n    // matches with any text within {{ }}\r\n    const variableRegex = /{{([^{}]*)}}/g;\r\n    return label.replace(variableRegex, (full, group) => {\r\n      return _.get(timeseries, group, full);\r\n    });\r\n  }\r\n\r\n  testDatasource() {\r\n    return this.backendSrv\r\n      .datasourceRequest({\r\n        url: `${this.url}/cogniteloginstatus`,\r\n        method: 'GET',\r\n      })\r\n      .then(response => {\r\n        if (response.status === 200) {\r\n          if (response.data.data.loggedIn && response.data.data.project === this.project) {\r\n            return {\r\n              status: 'success',\r\n              message: 'Your Cognite credentials are valid',\r\n              title: 'Success',\r\n            };\r\n          }\r\n          return {\r\n            status: 'error',\r\n            message: 'Your Cognite credentials are invalid',\r\n            title: 'Error',\r\n          };\r\n        }\r\n      });\r\n  }\r\n}\r\n","import {\r\n  DataSourceRequestOptions,\r\n  isError,\r\n  TimeSeriesResponseItem,\r\n  QueryTarget,\r\n  QueryOptions,\r\n} from './types';\r\nimport { BackendSrv } from 'grafana/app/core/services/backend_srv';\r\nimport Utils from './utils';\r\n\r\n// Cache requests for 10 seconds\r\nconst cacheTime = 1000 * 10;\r\n\r\nconst queries = {\r\n  results: new Map(),\r\n  requests: new Map(),\r\n};\r\n\r\nexport const getQuery = async (query: DataSourceRequestOptions, backendSrv: BackendSrv) => {\r\n  const stringQuery = JSON.stringify(query);\r\n\r\n  if (queries.requests.has(stringQuery)) {\r\n    return queries.requests.get(stringQuery);\r\n  }\r\n  if (queries.results.has(stringQuery)) {\r\n    return queries.results.get(stringQuery);\r\n  }\r\n  const promise = backendSrv.datasourceRequest(query).then(\r\n    res => {\r\n      if (!res) {\r\n        // the item may not exist, or it may have been deleted\r\n        return {};\r\n      }\r\n      const asset = res;\r\n      if (!isError(asset)) {\r\n        queries.results.set(stringQuery, asset);\r\n        // set a timeout to clear the cache\r\n        setTimeout(() => {\r\n          queries.results.delete(stringQuery);\r\n          queries.requests.delete(stringQuery);\r\n        }, cacheTime);\r\n      }\r\n      queries.requests.delete(stringQuery);\r\n      return asset;\r\n    },\r\n    error => {\r\n      // clear the cache so that the request can be retried\r\n      queries.requests.delete(stringQuery);\r\n      // pass the error up to the caller\r\n      throw error;\r\n    }\r\n  );\r\n  queries.requests.set(stringQuery, promise);\r\n  return promise;\r\n};\r\n\r\nconst assetTimeseries = new Map<string, TimeSeriesResponseItem[]>();\r\n\r\nexport const getTimeseries = (options: QueryOptions, target: QueryTarget) => {\r\n  return assetTimeseries.get(Utils.timeseriesHash(options, target));\r\n};\r\n\r\nexport const setTimeseries = (\r\n  options: QueryOptions,\r\n  target: QueryTarget,\r\n  timeseries: TimeSeriesResponseItem[]\r\n) => {\r\n  assetTimeseries.set(Utils.timeseriesHash(options, target), timeseries);\r\n};\r\n\r\nconst cache = {\r\n  getQuery,\r\n  getTimeseries,\r\n  setTimeseries,\r\n};\r\n\r\nexport default cache;\r\n","import {\r\n  DataQueryRequestItem,\r\n  ParseType,\r\n  QueryOptions,\r\n  FilterOptions,\r\n  FilterType,\r\n  TimeSeriesResponseItem,\r\n  DataQueryAlias,\r\n  QueryTarget,\r\n} from './types';\r\nimport Utils from './utils';\r\nimport _ from 'lodash';\r\nimport { TemplateSrv } from 'grafana/app/features/templating/template_srv';\r\n\r\nexport const parseExpression = (\r\n  expr: string,\r\n  options: QueryOptions,\r\n  timeseries: TimeSeriesResponseItem[],\r\n  templateSrv: TemplateSrv,\r\n  target: QueryTarget\r\n): DataQueryRequestItem[] => {\r\n  // trim and replace all variables here (will also replace variables outside of timeseries{} filters)\r\n  const trimmedExpr = templateSrv.replace(expr.trim(), options.scopedVars);\r\n  // first check if it is just a simple `timeseries{}` or `timeseries{}[]`\r\n  if (isSimpleTimeseriesExpression(trimmedExpr)) {\r\n    const filterOptions = getAndApplyFilterOptions(trimmedExpr, templateSrv, options, timeseries);\r\n    target.aggregation = Utils.getAggregationDropdownString(filterOptions.aggregation);\r\n    target.granularity = filterOptions.granularity;\r\n    return timeseries.filter(ts => ts.selected).map(ts => ({ name: ts.name }));\r\n  }\r\n\r\n  const exprWithSpecialFunctions = parseSpecialFunctions(\r\n    trimmedExpr,\r\n    options,\r\n    timeseries,\r\n    templateSrv\r\n  );\r\n\r\n  return createDataQueryRequestItems(\r\n    exprWithSpecialFunctions,\r\n    options,\r\n    timeseries,\r\n    templateSrv,\r\n    ''\r\n  );\r\n};\r\n\r\nconst parseSpecialFunctions = (\r\n  expr: string,\r\n  options: QueryOptions,\r\n  timeseries: TimeSeriesResponseItem[],\r\n  templateSrv: TemplateSrv\r\n) => {\r\n  let newExpr = expr;\r\n  // look for sum(), max(), min(), or avg() with timeseries in it\r\n  const funcRegex = /(sum|max|min|avg)\\(timeseries.*?\\)/gi;\r\n  const funcRegexMatches = newExpr.match(funcRegex);\r\n  if (funcRegexMatches) {\r\n    for (const match of funcRegexMatches) {\r\n      // the match might match too much, so we need to parse the string more\r\n      const matchIndex = newExpr.indexOf(match);\r\n      if (matchIndex < 0) continue;\r\n      const timeseriesString = findTimeseriesString(newExpr.substr(matchIndex));\r\n      // make sure that we have func(timeseries{}[]) and not a use of the function eg max(timeseries{}, 0)\r\n      if (match.charAt(4 + timeseriesString.length) !== ')') continue;\r\n      const actualMatchString = `${match.substr(0, 4)}${timeseriesString})`;\r\n      const filterOptions = getAndApplyFilterOptions(\r\n        timeseriesString,\r\n        templateSrv,\r\n        options,\r\n        timeseries\r\n      );\r\n      const selectedTs = timeseries.filter(ts => ts.selected);\r\n      let funcString = '';\r\n      if (match.substr(0, 3).toLowerCase() === 'sum') {\r\n        funcString = `([${selectedTs\r\n          .map(ts => getTempAliasString(ts, filterOptions))\r\n          .join('] + [')}])`;\r\n      } else {\r\n        if (selectedTs.length <= 1) {\r\n          funcString = selectedTs.map(ts => `[${getTempAliasString(ts, filterOptions)}]`).join('');\r\n        } else {\r\n          funcString = `${match.slice(0, 3).toLowerCase()}([${selectedTs\r\n            .map(ts => getTempAliasString(ts, filterOptions))\r\n            .join('], [')}])`;\r\n        }\r\n      }\r\n      newExpr = newExpr.replace(actualMatchString, funcString);\r\n    }\r\n  }\r\n\r\n  return newExpr;\r\n};\r\n\r\n// recursively calls itself to create an array of DataQueryRequestItems\r\nconst createDataQueryRequestItems = (\r\n  expr: string,\r\n  options: QueryOptions,\r\n  timeseries: TimeSeriesResponseItem[],\r\n  templateSrv: TemplateSrv,\r\n  name: string\r\n): DataQueryRequestItem[] => {\r\n  let dataItems: DataQueryRequestItem[] = [];\r\n  // match timeseries{}[] or timeseries{}\r\n  const timeseriesString = findTimeseriesString(expr);\r\n  if (!timeseriesString) {\r\n    dataItems.push({\r\n      name,\r\n      function: expr,\r\n    });\r\n  } else {\r\n    const filterOptions = getAndApplyFilterOptions(\r\n      timeseriesString,\r\n      templateSrv,\r\n      options,\r\n      timeseries\r\n    );\r\n    const selectedTs = timeseries.filter(ts => ts.selected);\r\n\r\n    for (const ts of selectedTs) {\r\n      const replaceString = `[${getTempAliasString(ts, filterOptions)}]`;\r\n      let newExpr = expr.replace(timeseriesString, replaceString);\r\n\r\n      // we need to replace all similar timeseries requests\r\n      //  this is so that expressions like `timeseries{} - timeseries{}[avg]` work\r\n      // match all similar `timeseries{...}` and replace them\r\n      const tsFiltersString = findTimeseriesString(timeseriesString, false);\r\n      let index = newExpr.indexOf(tsFiltersString);\r\n      while (index >= 0) {\r\n        const similarTimeseriesString = findTimeseriesString(newExpr.substr(index));\r\n        const similarFilterOptions = getAndApplyFilterOptions(\r\n          similarTimeseriesString,\r\n          templateSrv,\r\n          options,\r\n          selectedTs\r\n        );\r\n        newExpr = newExpr.replace(\r\n          similarTimeseriesString,\r\n          `[${getTempAliasString(ts, similarFilterOptions)}]`\r\n        );\r\n        index = newExpr.indexOf(tsFiltersString);\r\n      }\r\n\r\n      dataItems = dataItems.concat(\r\n        createDataQueryRequestItems(newExpr, options, timeseries, templateSrv, name || ts.name)\r\n      );\r\n    }\r\n  }\r\n\r\n  return dataItems.map(item => {\r\n    updateAliases(item, options);\r\n    return item;\r\n  });\r\n};\r\n\r\nconst getAndApplyFilterOptions = (\r\n  timeseriesString: string,\r\n  templateSrv: TemplateSrv,\r\n  options: QueryOptions,\r\n  timeseries: TimeSeriesResponseItem[]\r\n) => {\r\n  const filterOptions = parse(timeseriesString, ParseType.Timeseries, templateSrv, options);\r\n  if (filterOptions.error) throw filterOptions.error;\r\n  Utils.applyFilters(filterOptions.filters, timeseries);\r\n  return filterOptions;\r\n};\r\n\r\n// puts in format: 'ID' or 'ID,aggr' or 'ID,aggr,gran'\r\nconst getTempAliasString = (timeseries: TimeSeriesResponseItem, filterOptions: FilterOptions) => {\r\n  return `${timeseries.id}${filterOptions.aggregation ? `,${filterOptions.aggregation}` : ''}${\r\n    filterOptions.granularity ? `,${filterOptions.granularity}` : ''\r\n  }`;\r\n};\r\n\r\nconst isSimpleTimeseriesExpression = (expr: string) => {\r\n  return findTimeseriesString(expr) === expr;\r\n};\r\n\r\n// finds and returns the first string of format 'timeseries{.*}' or 'timeseries{.*}[.*]', respecting brackets\r\nconst findTimeseriesString = (expr: string, withAggregateAndGranularity: boolean = true) => {\r\n  const timeseriesIndex = expr.indexOf('timeseries{');\r\n  if (timeseriesIndex < 0) return '';\r\n  const startIndex = timeseriesIndex + 'timeseries{'.length;\r\n  let openBracketCount = 1;\r\n  let index = 0;\r\n\r\n  while (openBracketCount > 0) {\r\n    if (startIndex + index >= expr.length) {\r\n      throw `ERROR: Unable to parse ${expr.substr(timeseriesIndex)}`;\r\n    }\r\n    if (expr.charAt(startIndex + index) === '{') openBracketCount += 1;\r\n    else if (expr.charAt(startIndex + index) === '}') openBracketCount -= 1;\r\n    else if (expr.charAt(startIndex + index) === '\"' || expr.charAt(startIndex + index) === \"'\") {\r\n      // skip ahead if we find a quote\r\n      const endQuote = expr.indexOf(expr.charAt(startIndex + index), startIndex + index + 1);\r\n      if (endQuote < 0) throw `ERROR: Unable to parse ${expr.substr(timeseriesIndex)}`;\r\n      index = endQuote - startIndex;\r\n    }\r\n    index += 1;\r\n  }\r\n  if (\r\n    withAggregateAndGranularity &&\r\n    startIndex + index < expr.length &&\r\n    expr.charAt(startIndex + index) === '['\r\n  ) {\r\n    const closeBracketIndex = expr.indexOf(']', startIndex + index);\r\n    if (closeBracketIndex > 0) index = closeBracketIndex - startIndex + 1;\r\n    else throw `ERROR: Unable to parse ${expr.substr(timeseriesIndex)}`;\r\n  }\r\n\r\n  return expr.substr(timeseriesIndex, index + 'timeseries{'.length);\r\n};\r\n\r\n// take in a dataqueryrequestitem and replace all [ID,agg] or [ID,agg,gran] with aliases\r\nconst updateAliases = (queryItem: DataQueryRequestItem, options: QueryOptions) => {\r\n  const regexSearch = /\\[.*?\\]/g;\r\n  const regexMatches = queryItem.function.match(regexSearch);\r\n  if (!queryItem.aliases) queryItem.aliases = [];\r\n  if (regexMatches) {\r\n    for (const match of regexMatches) {\r\n      // format is id, aggregation, granularity\r\n      const aliasParts = match\r\n        .substr(1, match.length - 2)\r\n        .split(',')\r\n        .filter(string => string.length)\r\n        .map(x => _.trim(x, ' \\'\"'));\r\n      // if we only get [ID] or [ALIAS], then there is no need to make an alias\r\n      if (aliasParts.length === 1) continue;\r\n      const alias: DataQueryAlias = {\r\n        alias: `alias${aliasParts.join('_')}`,\r\n        id: Number(aliasParts[0]),\r\n      };\r\n      alias.aggregate = aliasParts[1];\r\n      alias.granularity = aliasParts[2] || Utils.intervalToGranularity(options.intervalMs);\r\n      queryItem.function = queryItem.function.replace(match, `[${alias.alias}]`);\r\n      if (queryItem.aliases.find(x => x.alias === alias.alias)) continue;\r\n      queryItem.aliases.push(alias);\r\n    }\r\n  }\r\n};\r\n\r\nexport const parse = (\r\n  customQuery: string,\r\n  type: ParseType,\r\n  templateSrv: TemplateSrv,\r\n  options?: QueryOptions\r\n): FilterOptions => {\r\n  let query = customQuery;\r\n  if (type === ParseType.Timeseries || type === ParseType.Event) {\r\n    // replace variables with their values\r\n    if (options) {\r\n      query = templateSrv.replace(query, options.scopedVars);\r\n    } else {\r\n      for (const templateVariable of templateSrv.variables) {\r\n        query = query.replace(`[[${templateVariable.name}]]`, templateVariable.current.value);\r\n        query = query.replace(`$${templateVariable.name}`, templateVariable.current.value);\r\n      }\r\n    }\r\n  }\r\n\r\n  const filtersOptions = {\r\n    filters: [],\r\n    granularity: '',\r\n    aggregation: '',\r\n    error: '',\r\n  };\r\n\r\n  // Format: timeseries{ options }\r\n  //     or  timeseries{ options }[aggregation, granularity]\r\n  // regex pulls out the options string, as well as the aggre/gran string (if it exists)\r\n  const timeseriesRegex = /^timeseries\\{(.*)\\}(?:\\[(.*)\\])?$/;\r\n  const timeseriesMatch = query.match(timeseriesRegex);\r\n  const assetRegex = /^(?:asset|event)\\{(.*)\\}$/;\r\n  const assetMatch = query.match(assetRegex);\r\n  const filterRegex = /^filter\\{(.*)\\}$/;\r\n  const filterMatch = query.match(filterRegex);\r\n\r\n  let splitfilters: string[];\r\n  if (timeseriesMatch) {\r\n    // regex finds commas that are not followed by a closed bracket\r\n    splitfilters = Utils.splitFilters(timeseriesMatch[1], filtersOptions, false);\r\n  } else if (assetMatch) {\r\n    splitfilters = Utils.splitFilters(assetMatch[1], filtersOptions, true);\r\n  } else if (filterMatch) {\r\n    splitfilters = Utils.splitFilters(filterMatch[1], filtersOptions, false);\r\n  } else {\r\n    filtersOptions.error = `ERROR: Unable to parse expression ${query}`;\r\n  }\r\n\r\n  if (filtersOptions.error) {\r\n    return filtersOptions;\r\n  }\r\n\r\n  for (let f of splitfilters) {\r\n    f = _.trim(f, ' ');\r\n    if (f === '') continue;\r\n    const filter: any = {};\r\n    let i: number;\r\n    if ((i = f.indexOf(FilterType.RegexEquals)) > -1) {\r\n      filter.property = _.trim(f.substr(0, i), ' \\'\"');\r\n      filter.value = _.trim(f.substr(i + 2), ' \\'\"');\r\n      filter.type = FilterType.RegexEquals;\r\n    } else if ((i = f.indexOf(FilterType.RegexNotEquals)) > -1) {\r\n      filter.property = _.trim(f.substr(0, i), ' \\'\"');\r\n      filter.value = _.trim(f.substr(i + 2), ' \\'\"');\r\n      filter.type = FilterType.RegexNotEquals;\r\n    } else if ((i = f.indexOf(FilterType.NotEquals)) > -1) {\r\n      filter.property = _.trim(f.substr(0, i), ' \\'\"');\r\n      filter.value = _.trim(f.substr(i + 2), ' \\'\"');\r\n      filter.type = FilterType.NotEquals;\r\n    } else if ((i = f.indexOf(FilterType.Equals)) > -1) {\r\n      filter.property = _.trim(f.substr(0, i), ' \\'\"');\r\n      filter.value = _.trim(f.substr(i + 1), ' \\'\"');\r\n      filter.type = FilterType.Equals;\r\n    } else {\r\n      console.error(`Error parsing ${f}`);\r\n    }\r\n    filtersOptions.filters.push(filter);\r\n  }\r\n\r\n  if (timeseriesMatch) {\r\n    const aggregation = timeseriesMatch[2];\r\n    if (aggregation) {\r\n      const splitAggregation = aggregation.split(',');\r\n      filtersOptions.aggregation = _.trim(splitAggregation[0], ' \\'\"').toLowerCase();\r\n      filtersOptions.granularity =\r\n        splitAggregation.length > 1 ? _.trim(splitAggregation[1], ' \\'\"') : '';\r\n    }\r\n  }\r\n\r\n  return filtersOptions;\r\n};\r\n","import _ from 'lodash';\r\nimport { QueryCtrl } from 'grafana/app/plugins/sdk';\r\nimport './css/query_editor.css';\r\nimport CogniteDatasource from './datasource';\r\nimport { Tab, QueryTarget, TimeSeriesResponseItem } from './types';\r\n\r\nexport class CogniteQueryCtrl extends QueryCtrl {\r\n  static templateUrl = 'partials/query.editor.html';\r\n\r\n  target: QueryTarget;\r\n  assetVals: any;\r\n  datasource: CogniteDatasource;\r\n  panelCtrl: any;\r\n  aggregation = [\r\n    { value: 'none', name: 'None' },\r\n    { value: 'average', name: 'Average' },\r\n    { value: 'max', name: 'Max' },\r\n    { value: 'min', name: 'Min' },\r\n    { value: 'count', name: 'Count' },\r\n    { value: 'sum', name: 'Sum' },\r\n    { value: 'interpolation', name: 'Interpolation' },\r\n    { value: 'stepInterpolation', name: 'Step Interpolation' },\r\n    { value: 'continuousVariance', name: 'Continuous Variance' },\r\n    { value: 'discreteVariance', name: 'Discrete Variance' },\r\n    { value: 'totalVariation', name: 'Total Variation' },\r\n  ];\r\n  tabs = [\r\n    {\r\n      value: Tab.Timeseries,\r\n      name: 'Select Timeseries',\r\n      src: 'timeseriestab.html',\r\n    },\r\n    {\r\n      value: Tab.Asset,\r\n      name: 'Select Timeseries from Asset',\r\n      src: 'assettab.html',\r\n    },\r\n    { value: Tab.Custom, name: 'Custom Query', src: 'customtab.html' },\r\n  ];\r\n  currentTabIndex: number;\r\n  defaults = {\r\n    target: 'Start typing tag id here',\r\n    type: 'timeserie',\r\n    aggregation: 'average',\r\n    granularity: '',\r\n    label: '',\r\n    tab: Tab.Timeseries,\r\n    expr: '',\r\n    assetQuery: {\r\n      target: '',\r\n      old: undefined,\r\n      timeseries: [],\r\n      includeSubtrees: false,\r\n      func: '',\r\n      templatedTarget: '',\r\n    },\r\n  };\r\n  isAllSelected: boolean;\r\n\r\n  /** @ngInject **/\r\n  constructor($scope, $injector, private templateSrv) {\r\n    super($scope, $injector);\r\n\r\n    _.defaultsDeep(this.target, this.defaults);\r\n\r\n    this.currentTabIndex = this.tabs.findIndex(x => x.value === this.target.tab) || 0;\r\n    if (this.target.tab !== Tab.Asset) {\r\n      this.target.assetQuery.timeseries = [];\r\n      this.target.assetQuery.old = undefined;\r\n    }\r\n    this.isAllSelected =\r\n      this.target.assetQuery.timeseries &&\r\n      this.target.assetQuery.timeseries.every(ts => ts.selected);\r\n  }\r\n\r\n  getOptions(query: string, type: string) {\r\n    return this.datasource.getOptionsForDropdown(query || '', type).then(options => {\r\n      _.defer(() => this.$scope.$digest()); // need to force the update on the dropdown\r\n      return options;\r\n    });\r\n  }\r\n\r\n  onChangeInternal() {\r\n    this.refresh(); // Asks the panel to refresh data.\r\n  }\r\n\r\n  changeTab(index: number) {\r\n    this.currentTabIndex = index;\r\n    this.target.tab = this.tabs[index].value;\r\n    this.refresh();\r\n  }\r\n\r\n  toggleCheckboxes() {\r\n    this.isAllSelected = !this.isAllSelected;\r\n    this.target.assetQuery.timeseries.forEach(ts => (ts.selected = this.isAllSelected));\r\n  }\r\n\r\n  selectOption(timeseries: TimeSeriesResponseItem) {\r\n    timeseries.selected = !timeseries.selected;\r\n    this.isAllSelected = this.target.assetQuery.timeseries.every(ts => ts.selected);\r\n  }\r\n\r\n  getCollapsedText() {\r\n    if (this.target.tab === Tab.Timeseries) {\r\n      return `Timeseries: ${this.target.target} ${this.target.error}`;\r\n    }\r\n    if (this.target.tab === Tab.Asset) {\r\n      return `Timeseries from Asset: ${this.target.assetQuery.target} ${this.target.error}`;\r\n    }\r\n    if (this.target.tab === Tab.Custom) {\r\n      return `Custom Query: ${this.target.expr} ${this.target.error}`;\r\n    }\r\n    return '';\r\n  }\r\n}\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__9__;","\nvar content = require(\"!!../../node_modules/css-loader/dist/cjs.js??ref--5-1!./query_editor.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/dist/cjs.js??ref--5-1!./query_editor.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/dist/cjs.js??ref--5-1!./query_editor.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","exports = module.exports = require(\"../../node_modules/css-loader/dist/runtime/api.js\")(true);\n// Module\nexports.push([module.id, \".min-width-10 {\\r\\n  min-width: 10rem;\\r\\n}\\r\\n\\r\\n.min-width-12 {\\r\\n  min-width: 12rem;\\r\\n}\\r\\n\\r\\n.min-width-20 {\\r\\n  min-width: 20rem;\\r\\n}\\r\\n\\r\\n.gf-form-select-wrapper select.gf-form-input {\\r\\n  height: 2.64rem;\\r\\n}\\r\\n\\r\\n.gf-form-select-wrapper--caret-indent.gf-form-select-wrapper::after {\\r\\n  right: 0.775rem;\\r\\n}\\r\\n\\r\\n.gf-tabs-cognite.active:before,\\r\\n.gf-tabs-cognite.active:focus:before,\\r\\n.gf-tabs-cognite.active:hover:before {\\r\\n  background-image: linear-gradient(90deg, #33b5e5 0, #00b3ff 99%, #1b1b1b);\\r\\n}\\r\\n\\r\\ninput[type='checkbox'] {\\r\\n  margin: 4px;\\r\\n}\\r\\n\\r\\n.custom-query {\\r\\n  font-family: monospace;\\r\\n}\\r\\n\\r\\npre code {\\r\\n  line-height: 2;\\r\\n}\\r\\n\\r\\n.cognite-timeseries-list-checkbox {\\r\\n  margin-right: 10px;\\r\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"query_editor.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,eAAe;AACjB;;AAEA;;;EAGE,yEAAyE;AAC3E;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,kBAAkB;AACpB\",\"file\":\"query_editor.css\",\"sourcesContent\":[\".min-width-10 {\\r\\n  min-width: 10rem;\\r\\n}\\r\\n\\r\\n.min-width-12 {\\r\\n  min-width: 12rem;\\r\\n}\\r\\n\\r\\n.min-width-20 {\\r\\n  min-width: 20rem;\\r\\n}\\r\\n\\r\\n.gf-form-select-wrapper select.gf-form-input {\\r\\n  height: 2.64rem;\\r\\n}\\r\\n\\r\\n.gf-form-select-wrapper--caret-indent.gf-form-select-wrapper::after {\\r\\n  right: 0.775rem;\\r\\n}\\r\\n\\r\\n.gf-tabs-cognite.active:before,\\r\\n.gf-tabs-cognite.active:focus:before,\\r\\n.gf-tabs-cognite.active:hover:before {\\r\\n  background-image: linear-gradient(90deg, #33b5e5 0, #00b3ff 99%, #1b1b1b);\\r\\n}\\r\\n\\r\\ninput[type='checkbox'] {\\r\\n  margin: 4px;\\r\\n}\\r\\n\\r\\n.custom-query {\\r\\n  font-family: monospace;\\r\\n}\\r\\n\\r\\npre code {\\r\\n  line-height: 2;\\r\\n}\\r\\n\\r\\n.cognite-timeseries-list-checkbox {\\r\\n  margin-right: 10px;\\r\\n}\\r\\n\"]}]);\n\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return '@media ' + item[2] + '{' + content + '}';\n      } else {\n        return content;\n      }\n    }).join('');\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","export class CogniteConfigCtrl {\r\n  static templateUrl = 'partials/config.html';\r\n  current: any;\r\n\r\n  /** @ngInject **/\r\n  constructor($scope) {}\r\n}\r\n","import { Annotation } from './types';\r\nimport Utils from './utils';\r\n\r\nexport class CogniteAnnotationsQueryCtrl {\r\n  public static templateUrl = 'partials/annotations.editor.html';\r\n  annotation: Annotation;\r\n\r\n  verify() {\r\n    // simple verification that the queries are in the right format\r\n    this.annotation.error = '';\r\n    const errorObj = { error: '' };\r\n\r\n    // check the query expression\r\n    if (!this.annotation.expr) {\r\n      this.annotation.error = `Error: Query expression required.`;\r\n    } else {\r\n      const match = this.annotation.expr.match(/^event\\{(.*)\\}$/);\r\n      if (!match) {\r\n        this.annotation.error = `Error: Unable to parse ${\r\n          this.annotation.expr\r\n        } | Expected format: event{param=value,...}`;\r\n      } else if (!Utils.splitFilters(match[1], errorObj, true)) {\r\n        this.annotation.error = `${errorObj.error} | Expected format: event{param=value,...}`;\r\n      }\r\n    }\r\n    // check the filter expression (if it exists)\r\n    if (!this.annotation.error && this.annotation.filter) {\r\n      const match = this.annotation.filter.match(/^filter\\{(.*)\\}$/);\r\n      if (!match) {\r\n        this.annotation.error = `Error: Unable to parse ${\r\n          this.annotation.filter\r\n        } | Expected format: filter{property [=|!=|=~|!~] value,...}`;\r\n      } else if (!Utils.splitFilters(match[1], errorObj, false)) {\r\n        this.annotation.error = `${\r\n          errorObj.error\r\n        } | Expected format: filter{property [=|!=|=~|!~] value,...}`;\r\n      }\r\n    }\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport React from 'react';\r\nimport { VariableQueryData, VariableQueryProps } from './types';\r\n\r\nexport class CogniteVariableQueryCtrl extends React.PureComponent<\r\n  VariableQueryProps,\r\n  VariableQueryData\r\n> {\r\n  defaults: VariableQueryData = {\r\n    query: '',\r\n    filter: '',\r\n  };\r\n\r\n  constructor(props: VariableQueryProps) {\r\n    super(props);\r\n    this.state = Object.assign(this.defaults, this.props.query);\r\n  }\r\n\r\n  handleChange(event, prop: 'query' | 'filter') {\r\n    const state: any = {\r\n      [prop]: event.target.value,\r\n    };\r\n    this.setState(state);\r\n  }\r\n\r\n  handleBlur() {\r\n    this.props.onChange(this.state, this.state.query);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div className=\"gf-form gf-form--grow\">\r\n          <span className=\"gf-form-label query-keyword fix-query-keyword width-10\">Query</span>\r\n          <input\r\n            type=\"text\"\r\n            className=\"gf-form-input\"\r\n            value={this.state.query}\r\n            onChange={e => this.handleChange(e, 'query')}\r\n            onBlur={e => this.handleBlur()}\r\n            placeholder=\"eg: asset{name='example', assetSubtrees=[123456789]}\"\r\n            required\r\n          />\r\n        </div>\r\n        <div className=\"gf-form gf-form--grow\">\r\n          <span className=\"gf-form-label query-keyword fix-query-keyword width-10\">Filter</span>\r\n          <input\r\n            type=\"text\"\r\n            className=\"gf-form-input\"\r\n            value={this.state.filter}\r\n            onChange={e => this.handleChange(e, 'filter')}\r\n            onBlur={e => this.handleBlur()}\r\n            placeholder=\"eg: filter{name=~'.*test.*', isStep=1, metadata.key1!=false}\"\r\n          />\r\n        </div>\r\n        <div className=\"gf-form--grow\">\r\n          <pre>\r\n            {`  Query for assets using the '/assets/search' endpoint\r\n    Format is asset{param=value,...}\r\n  Then, filter on these assets\r\n    Format is filter{property comparator value,...}\r\n    Comparator can be =, !=, =~, !~ `}\r\n          </pre>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n"],"sourceRoot":""}